"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/parsers/paymentParser.ts":
/*!****************************************!*\
  !*** ./utils/parsers/paymentParser.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parsePayment: function() { return /* binding */ parsePayment; }\n/* harmony export */ });\n/**\n * Parser for payment information (LCP amount, frequency, annual increase)\n */ function parsePayment(rawText) {\n    const result = {};\n    // Extract Payment Type and LCP Amount\n    // Logic:\n    // 1. Ignore GP (Guaranteed Payments) - only focus on LCP rows\n    // 2. Use the LCP column value (last column) as the available amount\n    // 3. Find first LCP payment where LCP column > $0 (available payments)\n    // Pattern: Date\\tPayment\\tType\\tSold\\tGuaranteed\\tLCP\n    // Example: 11/1/2025\\t$11,610.60\\tLCP\\t$6,501.94\\t$0.00\\t$5,108.66\n    //          (LCP column = $5,108.66 is the available amount to quote)\n    const paymentRowRegex = /(\\d{1,2}\\/\\d{1,2}\\/\\d{4})\\s+\\$?[\\d,]+\\.?\\d*\\s+(LCP|GP|Guaranteed|COLA)\\s+\\$?([\\d,]+\\.?\\d*)\\s+\\$?([\\d,]+\\.?\\d*)\\s+\\$?([\\d,]+\\.?\\d*)/g;\n    let match;\n    const lcpRows = [];\n    while((match = paymentRowRegex.exec(rawText)) !== null){\n        const dateStr = match[1];\n        const type = match[2];\n        const soldAmount = parseFloat(match[3].replace(/,/g, \"\"));\n        const lcpAmount = parseFloat(match[5].replace(/,/g, \"\"));\n        // Only process LCP type rows\n        if (type !== \"LCP\") continue;\n        // Only include rows where LCP column has available amount > 0\n        if (!(lcpAmount > 0)) continue;\n        const [m, d, y] = dateStr.split(\"/\").map(Number);\n        const date = new Date(y, m - 1, d);\n        lcpRows.push({\n            date,\n            dateStr,\n            sold: soldAmount,\n            lcp: lcpAmount\n        });\n    }\n    if (lcpRows.length > 0) {\n        // Sort by ascending date\n        lcpRows.sort((a, b)=>a.date.getTime() - b.date.getTime());\n        // Start Date Logic: MAX(6 months from today, first available LCP date)\n        const today = new Date();\n        // Calculate 6 months from today properly\n        let sixMonthsLater = new Date(today);\n        sixMonthsLater.setMonth(sixMonthsLater.getMonth() + 6);\n        const firstLcpDate = lcpRows[0].date;\n        // Use whichever is later\n        const startDate = firstLcpDate > sixMonthsLater ? firstLcpDate : sixMonthsLater;\n        // Format date as M/D/YYYY\n        const startMonth = startDate.getMonth() + 1;\n        const startDay = startDate.getDate();\n        const startYear = startDate.getFullYear();\n        result.paymentStartDate = \"\".concat(startMonth, \"/\").concat(startDay, \"/\").concat(startYear);\n        // Note: End date will be calculated in accessDataParser.ts using age rule\n        // (TODAY + MIN(30 years, 75 - age)), not from payment table\n        result.paymentEndDate = lcpRows[lcpRows.length - 1].dateStr;\n        // Payment amount should be the first available LCP amount\n        result.typeOfPayment = \"LCP\";\n        result.paymentAmount = lcpRows[0].lcp.toFixed(2);\n    }\n    // Fallback: If no LCP found with new logic, try old pattern (kept for safety)\n    if (!result.paymentAmount) {\n        const fallbackMatch = rawText.match(/\\d{1,2}\\/\\d{1,2}\\/\\d{4}\\s+\\$?[\\d,]+\\.?\\d*\\s+LCP\\s+\\$?[\\d,]+\\.?\\d*\\s+\\$?[\\d,]+\\.?\\d*\\s+\\$?([\\d,]+\\.?\\d*)/);\n        if (fallbackMatch) {\n            const amount = fallbackMatch[1].replace(/,/g, \"\");\n            if (parseFloat(amount) > 0) {\n                result.paymentAmount = amount;\n                result.typeOfPayment = \"LCP\";\n            }\n        }\n    }\n    // Determine payment frequency (Monthly if we see consecutive months)\n    const monthlyPaymentPattern = /\\d{1,2}\\/\\d{1,2}\\/\\d{4}\\s+\\$[\\d,]+\\.?\\d*.*\\n.*\\d{1,2}\\/\\d{1,2}\\/\\d{4}\\s+\\$[\\d,]+\\.?\\d*/;\n    if (monthlyPaymentPattern.test(rawText)) {\n        result.paymentFrequency = \"Monthly\";\n    }\n    // Calculate Annual Increase % from payment changes\n    // Logic: Only use available LCP payments (Sold=$0, LCP>$0)\n    if (lcpRows.length >= 2) {\n        const firstAmount = lcpRows[0].lcp;\n        let secondAmount = firstAmount;\n        for(let i = 1; i < lcpRows.length; i++){\n            if (Math.abs(lcpRows[i].lcp - firstAmount) > 0.01) {\n                secondAmount = lcpRows[i].lcp;\n                break;\n            }\n        }\n        if (secondAmount !== firstAmount && firstAmount > 0) {\n            const percentageIncrease = (secondAmount - firstAmount) / firstAmount * 100;\n            result.annualIncrease = percentageIncrease.toFixed(2);\n        }\n    }\n    return result;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3BhcnNlcnMvcGF5bWVudFBhcnNlci50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0NBRUMsR0FFTSxTQUFTQSxhQUFhQyxPQUFlO0lBUTFDLE1BQU1DLFNBQWMsQ0FBQztJQUVyQixzQ0FBc0M7SUFDdEMsU0FBUztJQUNULDhEQUE4RDtJQUM5RCxvRUFBb0U7SUFDcEUsdUVBQXVFO0lBQ3ZFLHNEQUFzRDtJQUN0RCxtRUFBbUU7SUFDbkUscUVBQXFFO0lBRXJFLE1BQU1DLGtCQUFrQjtJQUV4QixJQUFJQztJQUNKLE1BQU1DLFVBQTZFLEVBQUU7SUFFckYsTUFBTyxDQUFDRCxRQUFRRCxnQkFBZ0JHLElBQUksQ0FBQ0wsUUFBTyxNQUFPLEtBQU07UUFDdkQsTUFBTU0sVUFBVUgsS0FBSyxDQUFDLEVBQUU7UUFDeEIsTUFBTUksT0FBT0osS0FBSyxDQUFDLEVBQUU7UUFDckIsTUFBTUssYUFBYUMsV0FBV04sS0FBSyxDQUFDLEVBQUUsQ0FBQ08sT0FBTyxDQUFDLE1BQU07UUFDckQsTUFBTUMsWUFBWUYsV0FBV04sS0FBSyxDQUFDLEVBQUUsQ0FBQ08sT0FBTyxDQUFDLE1BQU07UUFFcEQsNkJBQTZCO1FBQzdCLElBQUlILFNBQVMsT0FBTztRQUVwQiw4REFBOEQ7UUFDOUQsSUFBSSxDQUFFSSxDQUFBQSxZQUFZLElBQUk7UUFFdEIsTUFBTSxDQUFDQyxHQUFHQyxHQUFHQyxFQUFFLEdBQUdSLFFBQVFTLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUNDO1FBQ3pDLE1BQU1DLE9BQU8sSUFBSUMsS0FBS0wsR0FBR0YsSUFBSSxHQUFHQztRQUNoQ1QsUUFBUWdCLElBQUksQ0FBQztZQUFFRjtZQUFNWjtZQUFTZSxNQUFNYjtZQUFZYyxLQUFLWDtRQUFVO0lBQ2pFO0lBRUEsSUFBSVAsUUFBUW1CLE1BQU0sR0FBRyxHQUFHO1FBQ3RCLHlCQUF5QjtRQUN6Qm5CLFFBQVFvQixJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsRUFBRVAsSUFBSSxDQUFDUyxPQUFPLEtBQUtELEVBQUVSLElBQUksQ0FBQ1MsT0FBTztRQUV4RCx1RUFBdUU7UUFDdkUsTUFBTUMsUUFBUSxJQUFJVDtRQUNsQix5Q0FBeUM7UUFDekMsSUFBSVUsaUJBQWlCLElBQUlWLEtBQUtTO1FBQzlCQyxlQUFlQyxRQUFRLENBQUNELGVBQWVFLFFBQVEsS0FBSztRQUVwRCxNQUFNQyxlQUFlNUIsT0FBTyxDQUFDLEVBQUUsQ0FBQ2MsSUFBSTtRQUVwQyx5QkFBeUI7UUFDekIsTUFBTWUsWUFBWUQsZUFBZUgsaUJBQWlCRyxlQUFlSDtRQUVqRSwwQkFBMEI7UUFDMUIsTUFBTUssYUFBYUQsVUFBVUYsUUFBUSxLQUFLO1FBQzFDLE1BQU1JLFdBQVdGLFVBQVVHLE9BQU87UUFDbEMsTUFBTUMsWUFBWUosVUFBVUssV0FBVztRQUN2Q3JDLE9BQU9zQyxnQkFBZ0IsR0FBRyxHQUFpQkosT0FBZEQsWUFBVyxLQUFlRyxPQUFaRixVQUFTLEtBQWEsT0FBVkU7UUFFdkQsMEVBQTBFO1FBQzFFLDREQUE0RDtRQUM1RHBDLE9BQU91QyxjQUFjLEdBQUdwQyxPQUFPLENBQUNBLFFBQVFtQixNQUFNLEdBQUcsRUFBRSxDQUFDakIsT0FBTztRQUUzRCwwREFBMEQ7UUFDMURMLE9BQU93QyxhQUFhLEdBQUc7UUFDdkJ4QyxPQUFPeUMsYUFBYSxHQUFHdEMsT0FBTyxDQUFDLEVBQUUsQ0FBQ2tCLEdBQUcsQ0FBQ3FCLE9BQU8sQ0FBQztJQUNoRDtJQUVBLDhFQUE4RTtJQUM5RSxJQUFJLENBQUMxQyxPQUFPeUMsYUFBYSxFQUFFO1FBQ3pCLE1BQU1FLGdCQUFnQjVDLFFBQVFHLEtBQUssQ0FBQztRQUNwQyxJQUFJeUMsZUFBZTtZQUNqQixNQUFNQyxTQUFTRCxhQUFhLENBQUMsRUFBRSxDQUFDbEMsT0FBTyxDQUFDLE1BQU07WUFDOUMsSUFBSUQsV0FBV29DLFVBQVUsR0FBRztnQkFDMUI1QyxPQUFPeUMsYUFBYSxHQUFHRztnQkFDdkI1QyxPQUFPd0MsYUFBYSxHQUFHO1lBQ3pCO1FBQ0Y7SUFDRjtJQUVBLHFFQUFxRTtJQUNyRSxNQUFNSyx3QkFBd0I7SUFDOUIsSUFBSUEsc0JBQXNCQyxJQUFJLENBQUMvQyxVQUFVO1FBQ3ZDQyxPQUFPK0MsZ0JBQWdCLEdBQUc7SUFDNUI7SUFFQSxtREFBbUQ7SUFDbkQsMkRBQTJEO0lBQzNELElBQUk1QyxRQUFRbUIsTUFBTSxJQUFJLEdBQUc7UUFDdkIsTUFBTTBCLGNBQWM3QyxPQUFPLENBQUMsRUFBRSxDQUFDa0IsR0FBRztRQUNsQyxJQUFJNEIsZUFBZUQ7UUFDbkIsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUkvQyxRQUFRbUIsTUFBTSxFQUFFNEIsSUFBSztZQUN2QyxJQUFJQyxLQUFLQyxHQUFHLENBQUNqRCxPQUFPLENBQUMrQyxFQUFFLENBQUM3QixHQUFHLEdBQUcyQixlQUFlLE1BQU07Z0JBQ2pEQyxlQUFlOUMsT0FBTyxDQUFDK0MsRUFBRSxDQUFDN0IsR0FBRztnQkFDN0I7WUFDRjtRQUNGO1FBQ0EsSUFBSTRCLGlCQUFpQkQsZUFBZUEsY0FBYyxHQUFHO1lBQ25ELE1BQU1LLHFCQUFxQixDQUFFSixlQUFlRCxXQUFVLElBQUtBLGNBQWU7WUFDMUVoRCxPQUFPc0QsY0FBYyxHQUFHRCxtQkFBbUJYLE9BQU8sQ0FBQztRQUNyRDtJQUNGO0lBRUEsT0FBTzFDO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvcGFyc2Vycy9wYXltZW50UGFyc2VyLnRzP2FjOWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQYXJzZXIgZm9yIHBheW1lbnQgaW5mb3JtYXRpb24gKExDUCBhbW91bnQsIGZyZXF1ZW5jeSwgYW5udWFsIGluY3JlYXNlKVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVBheW1lbnQocmF3VGV4dDogc3RyaW5nKToge1xuICB0eXBlT2ZQYXltZW50Pzogc3RyaW5nXG4gIHBheW1lbnRBbW91bnQ/OiBzdHJpbmdcbiAgcGF5bWVudEZyZXF1ZW5jeT86IHN0cmluZ1xuICBhbm51YWxJbmNyZWFzZT86IHN0cmluZ1xuICBwYXltZW50U3RhcnREYXRlPzogc3RyaW5nXG4gIHBheW1lbnRFbmREYXRlPzogc3RyaW5nXG59IHtcbiAgY29uc3QgcmVzdWx0OiBhbnkgPSB7fVxuXG4gIC8vIEV4dHJhY3QgUGF5bWVudCBUeXBlIGFuZCBMQ1AgQW1vdW50XG4gIC8vIExvZ2ljOlxuICAvLyAxLiBJZ25vcmUgR1AgKEd1YXJhbnRlZWQgUGF5bWVudHMpIC0gb25seSBmb2N1cyBvbiBMQ1Agcm93c1xuICAvLyAyLiBVc2UgdGhlIExDUCBjb2x1bW4gdmFsdWUgKGxhc3QgY29sdW1uKSBhcyB0aGUgYXZhaWxhYmxlIGFtb3VudFxuICAvLyAzLiBGaW5kIGZpcnN0IExDUCBwYXltZW50IHdoZXJlIExDUCBjb2x1bW4gPiAkMCAoYXZhaWxhYmxlIHBheW1lbnRzKVxuICAvLyBQYXR0ZXJuOiBEYXRlXFx0UGF5bWVudFxcdFR5cGVcXHRTb2xkXFx0R3VhcmFudGVlZFxcdExDUFxuICAvLyBFeGFtcGxlOiAxMS8xLzIwMjVcXHQkMTEsNjEwLjYwXFx0TENQXFx0JDYsNTAxLjk0XFx0JDAuMDBcXHQkNSwxMDguNjZcbiAgLy8gICAgICAgICAgKExDUCBjb2x1bW4gPSAkNSwxMDguNjYgaXMgdGhlIGF2YWlsYWJsZSBhbW91bnQgdG8gcXVvdGUpXG4gIFxuICBjb25zdCBwYXltZW50Um93UmVnZXggPSAvKFxcZHsxLDJ9XFwvXFxkezEsMn1cXC9cXGR7NH0pXFxzK1xcJD9bXFxkLF0rXFwuP1xcZCpcXHMrKExDUHxHUHxHdWFyYW50ZWVkfENPTEEpXFxzK1xcJD8oW1xcZCxdK1xcLj9cXGQqKVxccytcXCQ/KFtcXGQsXStcXC4/XFxkKilcXHMrXFwkPyhbXFxkLF0rXFwuP1xcZCopL2dcbiAgXG4gIGxldCBtYXRjaDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbFxuICBjb25zdCBsY3BSb3dzOiBBcnJheTx7IGRhdGU6IERhdGU7IGRhdGVTdHI6IHN0cmluZzsgc29sZDogbnVtYmVyOyBsY3A6IG51bWJlciB9PiA9IFtdXG5cbiAgd2hpbGUgKChtYXRjaCA9IHBheW1lbnRSb3dSZWdleC5leGVjKHJhd1RleHQpKSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGRhdGVTdHIgPSBtYXRjaFsxXVxuICAgIGNvbnN0IHR5cGUgPSBtYXRjaFsyXVxuICAgIGNvbnN0IHNvbGRBbW91bnQgPSBwYXJzZUZsb2F0KG1hdGNoWzNdLnJlcGxhY2UoLywvZywgJycpKVxuICAgIGNvbnN0IGxjcEFtb3VudCA9IHBhcnNlRmxvYXQobWF0Y2hbNV0ucmVwbGFjZSgvLC9nLCAnJykpXG5cbiAgICAvLyBPbmx5IHByb2Nlc3MgTENQIHR5cGUgcm93c1xuICAgIGlmICh0eXBlICE9PSAnTENQJykgY29udGludWVcbiAgICBcbiAgICAvLyBPbmx5IGluY2x1ZGUgcm93cyB3aGVyZSBMQ1AgY29sdW1uIGhhcyBhdmFpbGFibGUgYW1vdW50ID4gMFxuICAgIGlmICghKGxjcEFtb3VudCA+IDApKSBjb250aW51ZVxuXG4gICAgY29uc3QgW20sIGQsIHldID0gZGF0ZVN0ci5zcGxpdCgnLycpLm1hcChOdW1iZXIpXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHksIG0gLSAxLCBkKVxuICAgIGxjcFJvd3MucHVzaCh7IGRhdGUsIGRhdGVTdHIsIHNvbGQ6IHNvbGRBbW91bnQsIGxjcDogbGNwQW1vdW50IH0pXG4gIH1cblxuICBpZiAobGNwUm93cy5sZW5ndGggPiAwKSB7XG4gICAgLy8gU29ydCBieSBhc2NlbmRpbmcgZGF0ZVxuICAgIGxjcFJvd3Muc29ydCgoYSwgYikgPT4gYS5kYXRlLmdldFRpbWUoKSAtIGIuZGF0ZS5nZXRUaW1lKCkpXG5cbiAgICAvLyBTdGFydCBEYXRlIExvZ2ljOiBNQVgoNiBtb250aHMgZnJvbSB0b2RheSwgZmlyc3QgYXZhaWxhYmxlIExDUCBkYXRlKVxuICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKVxuICAgIC8vIENhbGN1bGF0ZSA2IG1vbnRocyBmcm9tIHRvZGF5IHByb3Blcmx5XG4gICAgbGV0IHNpeE1vbnRoc0xhdGVyID0gbmV3IERhdGUodG9kYXkpXG4gICAgc2l4TW9udGhzTGF0ZXIuc2V0TW9udGgoc2l4TW9udGhzTGF0ZXIuZ2V0TW9udGgoKSArIDYpXG4gICAgXG4gICAgY29uc3QgZmlyc3RMY3BEYXRlID0gbGNwUm93c1swXS5kYXRlXG4gICAgXG4gICAgLy8gVXNlIHdoaWNoZXZlciBpcyBsYXRlclxuICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IGZpcnN0TGNwRGF0ZSA+IHNpeE1vbnRoc0xhdGVyID8gZmlyc3RMY3BEYXRlIDogc2l4TW9udGhzTGF0ZXJcbiAgICBcbiAgICAvLyBGb3JtYXQgZGF0ZSBhcyBNL0QvWVlZWVxuICAgIGNvbnN0IHN0YXJ0TW9udGggPSBzdGFydERhdGUuZ2V0TW9udGgoKSArIDFcbiAgICBjb25zdCBzdGFydERheSA9IHN0YXJ0RGF0ZS5nZXREYXRlKClcbiAgICBjb25zdCBzdGFydFllYXIgPSBzdGFydERhdGUuZ2V0RnVsbFllYXIoKVxuICAgIHJlc3VsdC5wYXltZW50U3RhcnREYXRlID0gYCR7c3RhcnRNb250aH0vJHtzdGFydERheX0vJHtzdGFydFllYXJ9YFxuXG4gICAgLy8gTm90ZTogRW5kIGRhdGUgd2lsbCBiZSBjYWxjdWxhdGVkIGluIGFjY2Vzc0RhdGFQYXJzZXIudHMgdXNpbmcgYWdlIHJ1bGVcbiAgICAvLyAoVE9EQVkgKyBNSU4oMzAgeWVhcnMsIDc1IC0gYWdlKSksIG5vdCBmcm9tIHBheW1lbnQgdGFibGVcbiAgICByZXN1bHQucGF5bWVudEVuZERhdGUgPSBsY3BSb3dzW2xjcFJvd3MubGVuZ3RoIC0gMV0uZGF0ZVN0clxuXG4gICAgLy8gUGF5bWVudCBhbW91bnQgc2hvdWxkIGJlIHRoZSBmaXJzdCBhdmFpbGFibGUgTENQIGFtb3VudFxuICAgIHJlc3VsdC50eXBlT2ZQYXltZW50ID0gJ0xDUCdcbiAgICByZXN1bHQucGF5bWVudEFtb3VudCA9IGxjcFJvd3NbMF0ubGNwLnRvRml4ZWQoMilcbiAgfVxuICBcbiAgLy8gRmFsbGJhY2s6IElmIG5vIExDUCBmb3VuZCB3aXRoIG5ldyBsb2dpYywgdHJ5IG9sZCBwYXR0ZXJuIChrZXB0IGZvciBzYWZldHkpXG4gIGlmICghcmVzdWx0LnBheW1lbnRBbW91bnQpIHtcbiAgICBjb25zdCBmYWxsYmFja01hdGNoID0gcmF3VGV4dC5tYXRjaCgvXFxkezEsMn1cXC9cXGR7MSwyfVxcL1xcZHs0fVxccytcXCQ/W1xcZCxdK1xcLj9cXGQqXFxzK0xDUFxccytcXCQ/W1xcZCxdK1xcLj9cXGQqXFxzK1xcJD9bXFxkLF0rXFwuP1xcZCpcXHMrXFwkPyhbXFxkLF0rXFwuP1xcZCopLylcbiAgICBpZiAoZmFsbGJhY2tNYXRjaCkge1xuICAgICAgY29uc3QgYW1vdW50ID0gZmFsbGJhY2tNYXRjaFsxXS5yZXBsYWNlKC8sL2csICcnKVxuICAgICAgaWYgKHBhcnNlRmxvYXQoYW1vdW50KSA+IDApIHtcbiAgICAgICAgcmVzdWx0LnBheW1lbnRBbW91bnQgPSBhbW91bnRcbiAgICAgICAgcmVzdWx0LnR5cGVPZlBheW1lbnQgPSAnTENQJ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIERldGVybWluZSBwYXltZW50IGZyZXF1ZW5jeSAoTW9udGhseSBpZiB3ZSBzZWUgY29uc2VjdXRpdmUgbW9udGhzKVxuICBjb25zdCBtb250aGx5UGF5bWVudFBhdHRlcm4gPSAvXFxkezEsMn1cXC9cXGR7MSwyfVxcL1xcZHs0fVxccytcXCRbXFxkLF0rXFwuP1xcZCouKlxcbi4qXFxkezEsMn1cXC9cXGR7MSwyfVxcL1xcZHs0fVxccytcXCRbXFxkLF0rXFwuP1xcZCovXG4gIGlmIChtb250aGx5UGF5bWVudFBhdHRlcm4udGVzdChyYXdUZXh0KSkge1xuICAgIHJlc3VsdC5wYXltZW50RnJlcXVlbmN5ID0gJ01vbnRobHknXG4gIH1cblxuICAvLyBDYWxjdWxhdGUgQW5udWFsIEluY3JlYXNlICUgZnJvbSBwYXltZW50IGNoYW5nZXNcbiAgLy8gTG9naWM6IE9ubHkgdXNlIGF2YWlsYWJsZSBMQ1AgcGF5bWVudHMgKFNvbGQ9JDAsIExDUD4kMClcbiAgaWYgKGxjcFJvd3MubGVuZ3RoID49IDIpIHtcbiAgICBjb25zdCBmaXJzdEFtb3VudCA9IGxjcFJvd3NbMF0ubGNwXG4gICAgbGV0IHNlY29uZEFtb3VudCA9IGZpcnN0QW1vdW50XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsY3BSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoTWF0aC5hYnMobGNwUm93c1tpXS5sY3AgLSBmaXJzdEFtb3VudCkgPiAwLjAxKSB7XG4gICAgICAgIHNlY29uZEFtb3VudCA9IGxjcFJvd3NbaV0ubGNwXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzZWNvbmRBbW91bnQgIT09IGZpcnN0QW1vdW50ICYmIGZpcnN0QW1vdW50ID4gMCkge1xuICAgICAgY29uc3QgcGVyY2VudGFnZUluY3JlYXNlID0gKChzZWNvbmRBbW91bnQgLSBmaXJzdEFtb3VudCkgLyBmaXJzdEFtb3VudCkgKiAxMDBcbiAgICAgIHJlc3VsdC5hbm51YWxJbmNyZWFzZSA9IHBlcmNlbnRhZ2VJbmNyZWFzZS50b0ZpeGVkKDIpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4iXSwibmFtZXMiOlsicGFyc2VQYXltZW50IiwicmF3VGV4dCIsInJlc3VsdCIsInBheW1lbnRSb3dSZWdleCIsIm1hdGNoIiwibGNwUm93cyIsImV4ZWMiLCJkYXRlU3RyIiwidHlwZSIsInNvbGRBbW91bnQiLCJwYXJzZUZsb2F0IiwicmVwbGFjZSIsImxjcEFtb3VudCIsIm0iLCJkIiwieSIsInNwbGl0IiwibWFwIiwiTnVtYmVyIiwiZGF0ZSIsIkRhdGUiLCJwdXNoIiwic29sZCIsImxjcCIsImxlbmd0aCIsInNvcnQiLCJhIiwiYiIsImdldFRpbWUiLCJ0b2RheSIsInNpeE1vbnRoc0xhdGVyIiwic2V0TW9udGgiLCJnZXRNb250aCIsImZpcnN0TGNwRGF0ZSIsInN0YXJ0RGF0ZSIsInN0YXJ0TW9udGgiLCJzdGFydERheSIsImdldERhdGUiLCJzdGFydFllYXIiLCJnZXRGdWxsWWVhciIsInBheW1lbnRTdGFydERhdGUiLCJwYXltZW50RW5kRGF0ZSIsInR5cGVPZlBheW1lbnQiLCJwYXltZW50QW1vdW50IiwidG9GaXhlZCIsImZhbGxiYWNrTWF0Y2giLCJhbW91bnQiLCJtb250aGx5UGF5bWVudFBhdHRlcm4iLCJ0ZXN0IiwicGF5bWVudEZyZXF1ZW5jeSIsImZpcnN0QW1vdW50Iiwic2Vjb25kQW1vdW50IiwiaSIsIk1hdGgiLCJhYnMiLCJwZXJjZW50YWdlSW5jcmVhc2UiLCJhbm51YWxJbmNyZWFzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/parsers/paymentParser.ts\n"));

/***/ })

});