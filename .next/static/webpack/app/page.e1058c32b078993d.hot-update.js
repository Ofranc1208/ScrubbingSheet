"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/parsers/paymentParser.ts":
/*!****************************************!*\
  !*** ./utils/parsers/paymentParser.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parsePayment: function() { return /* binding */ parsePayment; }\n/* harmony export */ });\n/**\n * Parser for payment information (LCP amount, frequency, annual increase)\n */ function parsePayment(rawText) {\n    const result = {};\n    // Extract Payment Type and LCP Amount\n    // Logic:\n    // 1. Ignore GP (Guaranteed Payments) - only focus on LCP rows\n    // 2. Use the LCP column value (last column) as the available amount\n    // 3. Find first LCP payment where LCP column > $0 (available payments)\n    // Pattern: Date\\tPayment\\tType\\tSold\\tGuaranteed\\tLCP\n    // Example: 11/1/2025\\t$11,610.60\\tLCP\\t$6,501.94\\t$0.00\\t$5,108.66\n    //          (LCP column = $5,108.66 is the available amount to quote)\n    const paymentRowRegex = /(\\d{1,2}\\/\\d{1,2}\\/\\d{4})\\s+\\$?[\\d,]+\\.?\\d*\\s+(LCP|GP|Guaranteed|COLA)\\s+\\$?([\\d,]+\\.?\\d*)\\s+\\$?([\\d,]+\\.?\\d*)\\s+\\$?([\\d,]+\\.?\\d*)/g;\n    let match;\n    const lcpRows = [];\n    while((match = paymentRowRegex.exec(rawText)) !== null){\n        const dateStr = match[1];\n        const type = match[2];\n        const soldAmount = parseFloat(match[3].replace(/,/g, \"\"));\n        const lcpAmount = parseFloat(match[5].replace(/,/g, \"\"));\n        // Only process LCP type rows\n        if (type !== \"LCP\") continue;\n        // Only include rows where LCP column has available amount > 0\n        if (!(lcpAmount > 0)) continue;\n        const [m, d, y] = dateStr.split(\"/\").map(Number);\n        const date = new Date(y, m - 1, d);\n        lcpRows.push({\n            date,\n            dateStr,\n            sold: soldAmount,\n            lcp: lcpAmount\n        });\n    }\n    if (lcpRows.length > 0) {\n        // Sort by ascending date\n        lcpRows.sort((a, b)=>a.date.getTime() - b.date.getTime());\n        // Start Date Logic: MAX(6 months from today, first available LCP date)\n        const today = new Date();\n        // Calculate 6 months from today properly\n        let sixMonthsLater = new Date(today);\n        sixMonthsLater.setMonth(sixMonthsLater.getMonth() + 6);\n        const firstLcpDate = lcpRows[0].date;\n        // Use whichever is later\n        const startDate = firstLcpDate > sixMonthsLater ? firstLcpDate : sixMonthsLater;\n        // Format date as M/D/YYYY\n        const startMonth = startDate.getMonth() + 1;\n        const startDay = startDate.getDate();\n        const startYear = startDate.getFullYear();\n        result.paymentStartDate = \"\".concat(startMonth, \"/\").concat(startDay, \"/\").concat(startYear);\n        // Note: End date will be calculated in accessDataParser.ts using age rule\n        // (TODAY + MIN(30 years, 75 - age)), not from payment table\n        result.paymentEndDate = lcpRows[lcpRows.length - 1].dateStr;\n        // Payment amount should be the first available LCP amount\n        result.typeOfPayment = \"LCP\";\n        result.paymentAmount = lcpRows[0].lcp.toFixed(2);\n    }\n    // Fallback: If no LCP found with new logic, try old pattern (kept for safety)\n    if (!result.paymentAmount) {\n        const fallbackMatch = rawText.match(/\\d{1,2}\\/\\d{1,2}\\/\\d{4}\\s+\\$?[\\d,]+\\.?\\d*\\s+LCP\\s+\\$?[\\d,]+\\.?\\d*\\s+\\$?[\\d,]+\\.?\\d*\\s+\\$?([\\d,]+\\.?\\d*)/);\n        if (fallbackMatch) {\n            const amount = fallbackMatch[1].replace(/,/g, \"\");\n            if (parseFloat(amount) > 0) {\n                result.paymentAmount = amount;\n                result.typeOfPayment = \"LCP\";\n            }\n        }\n    }\n    // Determine payment frequency and handle annual payments\n    // Check for annual payments (same month, different years)\n    const annualPaymentPattern = /\\d{1,2}\\/\\d{1,2}\\/\\d{4}\\s+\\$[\\d,]+\\.?\\d*.*\\n.*\\d{1,2}\\/\\d{1,2}\\/\\d{4}\\s+\\$[\\d,]+\\.?\\d*/;\n    if (annualPaymentPattern.test(rawText)) {\n        // Check if payments are in the same month (annual) or different months (monthly)\n        const paymentLines = rawText.match(/\\d{1,2}\\/\\d{1,2}\\/\\d{4}\\s+\\$[\\d,]+\\.?\\d*/g) || [];\n        if (paymentLines.length >= 2) {\n            var _paymentLines_, _paymentLines_1;\n            const firstPayment = (_paymentLines_ = paymentLines[0]) === null || _paymentLines_ === void 0 ? void 0 : _paymentLines_.match(/(\\d{1,2})\\/\\d{1,2}\\/\\d{4}/);\n            const secondPayment = (_paymentLines_1 = paymentLines[1]) === null || _paymentLines_1 === void 0 ? void 0 : _paymentLines_1.match(/(\\d{1,2})\\/\\d{1,2}\\/\\d{4}/);\n            if (firstPayment && secondPayment) {\n                const firstMonth = parseInt(firstPayment[1]);\n                const secondMonth = parseInt(secondPayment[1]);\n                if (firstMonth === secondMonth) {\n                    // Same month = annual payments\n                    result.paymentFrequency = \"Annual\";\n                } else {\n                    // Different months = monthly payments\n                    result.paymentFrequency = \"Monthly\";\n                }\n            } else {\n                result.paymentFrequency = \"Monthly\" // Default fallback\n                ;\n            }\n        } else {\n            result.paymentFrequency = \"Monthly\" // Default fallback\n            ;\n        }\n    } else {\n        result.paymentFrequency = \"Monthly\" // Default fallback\n        ;\n    }\n    // If annual payments detected, convert to monthly equivalent\n    if (result.paymentFrequency === \"Annual\" && result.paymentAmount) {\n        const annualAmount = parseFloat(result.paymentAmount);\n        const monthlyAmount = annualAmount / 12;\n        result.paymentAmount = monthlyAmount.toFixed(2);\n        result.paymentFrequency = \"Monthly\" // Convert to monthly for calculations\n        ;\n    }\n    // Calculate Annual Increase % from payment changes\n    // Logic: Only use available LCP payments (Sold=$0, LCP>$0)\n    if (lcpRows.length >= 2) {\n        const firstAmount = lcpRows[0].lcp;\n        let secondAmount = firstAmount;\n        for(let i = 1; i < lcpRows.length; i++){\n            if (Math.abs(lcpRows[i].lcp - firstAmount) > 0.01) {\n                secondAmount = lcpRows[i].lcp;\n                break;\n            }\n        }\n        if (secondAmount !== firstAmount && firstAmount > 0) {\n            const percentageIncrease = (secondAmount - firstAmount) / firstAmount * 100;\n            result.annualIncrease = percentageIncrease.toFixed(2);\n        }\n    }\n    return result;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3BhcnNlcnMvcGF5bWVudFBhcnNlci50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0NBRUMsR0FFTSxTQUFTQSxhQUFhQyxPQUFlO0lBUTFDLE1BQU1DLFNBQWMsQ0FBQztJQUVyQixzQ0FBc0M7SUFDdEMsU0FBUztJQUNULDhEQUE4RDtJQUM5RCxvRUFBb0U7SUFDcEUsdUVBQXVFO0lBQ3ZFLHNEQUFzRDtJQUN0RCxtRUFBbUU7SUFDbkUscUVBQXFFO0lBRXJFLE1BQU1DLGtCQUFrQjtJQUV4QixJQUFJQztJQUNKLE1BQU1DLFVBQTZFLEVBQUU7SUFFckYsTUFBTyxDQUFDRCxRQUFRRCxnQkFBZ0JHLElBQUksQ0FBQ0wsUUFBTyxNQUFPLEtBQU07UUFDdkQsTUFBTU0sVUFBVUgsS0FBSyxDQUFDLEVBQUU7UUFDeEIsTUFBTUksT0FBT0osS0FBSyxDQUFDLEVBQUU7UUFDckIsTUFBTUssYUFBYUMsV0FBV04sS0FBSyxDQUFDLEVBQUUsQ0FBQ08sT0FBTyxDQUFDLE1BQU07UUFDckQsTUFBTUMsWUFBWUYsV0FBV04sS0FBSyxDQUFDLEVBQUUsQ0FBQ08sT0FBTyxDQUFDLE1BQU07UUFFcEQsNkJBQTZCO1FBQzdCLElBQUlILFNBQVMsT0FBTztRQUVwQiw4REFBOEQ7UUFDOUQsSUFBSSxDQUFFSSxDQUFBQSxZQUFZLElBQUk7UUFFdEIsTUFBTSxDQUFDQyxHQUFHQyxHQUFHQyxFQUFFLEdBQUdSLFFBQVFTLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUNDO1FBQ3pDLE1BQU1DLE9BQU8sSUFBSUMsS0FBS0wsR0FBR0YsSUFBSSxHQUFHQztRQUNoQ1QsUUFBUWdCLElBQUksQ0FBQztZQUFFRjtZQUFNWjtZQUFTZSxNQUFNYjtZQUFZYyxLQUFLWDtRQUFVO0lBQ2pFO0lBRUEsSUFBSVAsUUFBUW1CLE1BQU0sR0FBRyxHQUFHO1FBQ3RCLHlCQUF5QjtRQUN6Qm5CLFFBQVFvQixJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFB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LEdBQUdjLGNBQWNiLE9BQU8sQ0FBQztRQUM3QzFDLE9BQU9xRCxnQkFBZ0IsR0FBRyxVQUFVLHNDQUFzQzs7SUFDNUU7SUFFQSxtREFBbUQ7SUFDbkQsMkRBQTJEO0lBQzNELElBQUlsRCxRQUFRbUIsTUFBTSxJQUFJLEdBQUc7UUFDdkIsTUFBTWtDLGNBQWNyRCxPQUFPLENBQUMsRUFBRSxDQUFDa0IsR0FBRztRQUNsQyxJQUFJb0MsZUFBZUQ7UUFDbkIsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUl2RCxRQUFRbUIsTUFBTSxFQUFFb0MsSUFBSztZQUN2QyxJQUFJQyxLQUFLQyxHQUFHLENBQUN6RCxPQUFPLENBQUN1RCxFQUFFLENBQUNyQyxHQUFHLEdBQUdtQyxlQUFlLE1BQU07Z0JBQ2pEQyxlQUFldEQsT0FBTyxDQUFDdUQsRUFBRSxDQUFDckMsR0FBRztnQkFDN0I7WUFDRjtRQUNGO1FBQ0EsSUFBSW9DLGlCQUFpQkQsZUFBZUEsY0FBYyxHQUFHO1lBQ25ELE1BQU1LLHFCQUFxQixDQUFFSixlQUFlRCxXQUFVLElBQUtBLGNBQWU7WUFDMUV4RCxPQUFPOEQsY0FBYyxHQUFHRCxtQkFBbUJuQixPQUFPLENBQUM7UUFDckQ7SUFDRjtJQUVBLE9BQU8xQztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL3BhcnNlcnMvcGF5bWVudFBhcnNlci50cz9hYzllIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUGFyc2VyIGZvciBwYXltZW50IGluZm9ybWF0aW9uIChMQ1AgYW1vdW50LCBmcmVxdWVuY3ksIGFubnVhbCBpbmNyZWFzZSlcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQYXltZW50KHJhd1RleHQ6IHN0cmluZyk6IHtcbiAgdHlwZU9mUGF5bWVudD86IHN0cmluZ1xuICBwYXltZW50QW1vdW50Pzogc3RyaW5nXG4gIHBheW1lbnRGcmVxdWVuY3k/OiBzdHJpbmdcbiAgYW5udWFsSW5jcmVhc2U/OiBzdHJpbmdcbiAgcGF5bWVudFN0YXJ0RGF0ZT86IHN0cmluZ1xuICBwYXltZW50RW5kRGF0ZT86IHN0cmluZ1xufSB7XG4gIGNvbnN0IHJlc3VsdDogYW55ID0ge31cblxuICAvLyBFeHRyYWN0IFBheW1lbnQgVHlwZSBhbmQgTENQIEFtb3VudFxuICAvLyBMb2dpYzpcbiAgLy8gMS4gSWdub3JlIEdQIChHdWFyYW50ZWVkIFBheW1lbnRzKSAtIG9ubHkgZm9jdXMgb24gTENQIHJvd3NcbiAgLy8gMi4gVXNlIHRoZSBMQ1AgY29sdW1uIHZhbHVlIChsYXN0IGNvbHVtbikgYXMgdGhlIGF2YWlsYWJsZSBhbW91bnRcbiAgLy8gMy4gRmluZCBmaXJzdCBMQ1AgcGF5bWVudCB3aGVyZSBMQ1AgY29sdW1uID4gJDAgKGF2YWlsYWJsZSBwYXltZW50cylcbiAgLy8gUGF0dGVybjogRGF0ZVxcdFBheW1lbnRcXHRUeXBlXFx0U29sZFxcdEd1YXJhbnRlZWRcXHRMQ1BcbiAgLy8gRXhhbXBsZTogMTEvMS8yMDI1XFx0JDExLDYxMC42MFxcdExDUFxcdCQ2LDUwMS45NFxcdCQwLjAwXFx0JDUsMTA4LjY2XG4gIC8vICAgICAgICAgIChMQ1AgY29sdW1uID0gJDUsMTA4LjY2IGlzIHRoZSBhdmFpbGFibGUgYW1vdW50IHRvIHF1b3RlKVxuICBcbiAgY29uc3QgcGF5bWVudFJvd1JlZ2V4ID0gLyhcXGR7MSwyfVxcL1xcZHsxLDJ9XFwvXFxkezR9KVxccytcXCQ/W1xcZCxdK1xcLj9cXGQqXFxzKyhMQ1B8R1B8R3VhcmFudGVlZHxDT0xBKVxccytcXCQ/KFtcXGQsXStcXC4/XFxkKilcXHMrXFwkPyhbXFxkLF0rXFwuP1xcZCopXFxzK1xcJD8oW1xcZCxdK1xcLj9cXGQqKS9nXG4gIFxuICBsZXQgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGxcbiAgY29uc3QgbGNwUm93czogQXJyYXk8eyBkYXRlOiBEYXRlOyBkYXRlU3RyOiBzdHJpbmc7IHNvbGQ6IG51bWJlcjsgbGNwOiBudW1iZXIgfT4gPSBbXVxuXG4gIHdoaWxlICgobWF0Y2ggPSBwYXltZW50Um93UmVnZXguZXhlYyhyYXdUZXh0KSkgIT09IG51bGwpIHtcbiAgICBjb25zdCBkYXRlU3RyID0gbWF0Y2hbMV1cbiAgICBjb25zdCB0eXBlID0gbWF0Y2hbMl1cbiAgICBjb25zdCBzb2xkQW1vdW50ID0gcGFyc2VGbG9hdChtYXRjaFszXS5yZXBsYWNlKC8sL2csICcnKSlcbiAgICBjb25zdCBsY3BBbW91bnQgPSBwYXJzZUZsb2F0KG1hdGNoWzVdLnJlcGxhY2UoLywvZywgJycpKVxuXG4gICAgLy8gT25seSBwcm9jZXNzIExDUCB0eXBlIHJvd3NcbiAgICBpZiAodHlwZSAhPT0gJ0xDUCcpIGNvbnRpbnVlXG4gICAgXG4gICAgLy8gT25seSBpbmNsdWRlIHJvd3Mgd2hlcmUgTENQIGNvbHVtbiBoYXMgYXZhaWxhYmxlIGFtb3VudCA+IDBcbiAgICBpZiAoIShsY3BBbW91bnQgPiAwKSkgY29udGludWVcblxuICAgIGNvbnN0IFttLCBkLCB5XSA9IGRhdGVTdHIuc3BsaXQoJy8nKS5tYXAoTnVtYmVyKVxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh5LCBtIC0gMSwgZClcbiAgICBsY3BSb3dzLnB1c2goeyBkYXRlLCBkYXRlU3RyLCBzb2xkOiBzb2xkQW1vdW50LCBsY3A6IGxjcEFtb3VudCB9KVxuICB9XG5cbiAgaWYgKGxjcFJvd3MubGVuZ3RoID4gMCkge1xuICAgIC8vIFNvcnQgYnkgYXNjZW5kaW5nIGRhdGVcbiAgICBsY3BSb3dzLnNvcnQoKGEsIGIpID0+IGEuZGF0ZS5nZXRUaW1lKCkgLSBiLmRhdGUuZ2V0VGltZSgpKVxuXG4gICAgLy8gU3RhcnQgRGF0ZSBMb2dpYzogTUFYKDYgbW9udGhzIGZyb20gdG9kYXksIGZpcnN0IGF2YWlsYWJsZSBMQ1AgZGF0ZSlcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKClcbiAgICAvLyBDYWxjdWxhdGUgNiBtb250aHMgZnJvbSB0b2RheSBwcm9wZXJseVxuICAgIGxldCBzaXhNb250aHNMYXRlciA9IG5ldyBEYXRlKHRvZGF5KVxuICAgIHNpeE1vbnRoc0xhdGVyLnNldE1vbnRoKHNpeE1vbnRoc0xhdGVyLmdldE1vbnRoKCkgKyA2KVxuICAgIFxuICAgIGNvbnN0IGZpcnN0TGNwRGF0ZSA9IGxjcFJvd3NbMF0uZGF0ZVxuICAgIFxuICAgIC8vIFVzZSB3aGljaGV2ZXIgaXMgbGF0ZXJcbiAgICBjb25zdCBzdGFydERhdGUgPSBmaXJzdExjcERhdGUgPiBzaXhNb250aHNMYXRlciA/IGZpcnN0TGNwRGF0ZSA6IHNpeE1vbnRoc0xhdGVyXG4gICAgXG4gICAgLy8gRm9ybWF0IGRhdGUgYXMgTS9EL1lZWVlcbiAgICBjb25zdCBzdGFydE1vbnRoID0gc3RhcnREYXRlLmdldE1vbnRoKCkgKyAxXG4gICAgY29uc3Qgc3RhcnREYXkgPSBzdGFydERhdGUuZ2V0RGF0ZSgpXG4gICAgY29uc3Qgc3RhcnRZZWFyID0gc3RhcnREYXRlLmdldEZ1bGxZZWFyKClcbiAgICByZXN1bHQucGF5bWVudFN0YXJ0RGF0ZSA9IGAke3N0YXJ0TW9udGh9LyR7c3RhcnREYXl9LyR7c3RhcnRZZWFyfWBcblxuICAgIC8vIE5vdGU6IEVuZCBkYXRlIHdpbGwgYmUgY2FsY3VsYXRlZCBpbiBhY2Nlc3NEYXRhUGFyc2VyLnRzIHVzaW5nIGFnZSBydWxlXG4gICAgLy8gKFRPREFZICsgTUlOKDMwIHllYXJzLCA3NSAtIGFnZSkpLCBub3QgZnJvbSBwYXltZW50IHRhYmxlXG4gICAgcmVzdWx0LnBheW1lbnRFbmREYXRlID0gbGNwUm93c1tsY3BSb3dzLmxlbmd0aCAtIDFdLmRhdGVTdHJcblxuICAgIC8vIFBheW1lbnQgYW1vdW50IHNob3VsZCBiZSB0aGUgZmlyc3QgYXZhaWxhYmxlIExDUCBhbW91bnRcbiAgICByZXN1bHQudHlwZU9mUGF5bWVudCA9ICdMQ1AnXG4gICAgcmVzdWx0LnBheW1lbnRBbW91bnQgPSBsY3BSb3dzWzBdLmxjcC50b0ZpeGVkKDIpXG4gIH1cbiAgXG4gIC8vIEZhbGxiYWNrOiBJZiBubyBMQ1AgZm91bmQgd2l0aCBuZXcgbG9naWMsIHRyeSBvbGQgcGF0dGVybiAoa2VwdCBmb3Igc2FmZXR5KVxuICBpZiAoIXJlc3VsdC5wYXltZW50QW1vdW50KSB7XG4gICAgY29uc3QgZmFsbGJhY2tNYXRjaCA9IHJhd1RleHQubWF0Y2goL1xcZHsxLDJ9XFwvXFxkezEsMn1cXC9cXGR7NH1cXHMrXFwkP1tcXGQsXStcXC4/XFxkKlxccytMQ1BcXHMrXFwkP1tcXGQsXStcXC4/XFxkKlxccytcXCQ/W1xcZCxdK1xcLj9cXGQqXFxzK1xcJD8oW1xcZCxdK1xcLj9cXGQqKS8pXG4gICAgaWYgKGZhbGxiYWNrTWF0Y2gpIHtcbiAgICAgIGNvbnN0IGFtb3VudCA9IGZhbGxiYWNrTWF0Y2hbMV0ucmVwbGFjZSgvLC9nLCAnJylcbiAgICAgIGlmIChwYXJzZUZsb2F0KGFtb3VudCkgPiAwKSB7XG4gICAgICAgIHJlc3VsdC5wYXltZW50QW1vdW50ID0gYW1vdW50XG4gICAgICAgIHJlc3VsdC50eXBlT2ZQYXltZW50ID0gJ0xDUCdcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBEZXRlcm1pbmUgcGF5bWVudCBmcmVxdWVuY3kgYW5kIGhhbmRsZSBhbm51YWwgcGF5bWVudHNcbiAgLy8gQ2hlY2sgZm9yIGFubnVhbCBwYXltZW50cyAoc2FtZSBtb250aCwgZGlmZmVyZW50IHllYXJzKVxuICBjb25zdCBhbm51YWxQYXltZW50UGF0dGVybiA9IC9cXGR7MSwyfVxcL1xcZHsxLDJ9XFwvXFxkezR9XFxzK1xcJFtcXGQsXStcXC4/XFxkKi4qXFxuLipcXGR7MSwyfVxcL1xcZHsxLDJ9XFwvXFxkezR9XFxzK1xcJFtcXGQsXStcXC4/XFxkKi9cbiAgaWYgKGFubnVhbFBheW1lbnRQYXR0ZXJuLnRlc3QocmF3VGV4dCkpIHtcbiAgICAvLyBDaGVjayBpZiBwYXltZW50cyBhcmUgaW4gdGhlIHNhbWUgbW9udGggKGFubnVhbCkgb3IgZGlmZmVyZW50IG1vbnRocyAobW9udGhseSlcbiAgICBjb25zdCBwYXltZW50TGluZXMgPSByYXdUZXh0Lm1hdGNoKC9cXGR7MSwyfVxcL1xcZHsxLDJ9XFwvXFxkezR9XFxzK1xcJFtcXGQsXStcXC4/XFxkKi9nKSB8fCBbXVxuICAgIGlmIChwYXltZW50TGluZXMubGVuZ3RoID49IDIpIHtcbiAgICAgIGNvbnN0IGZpcnN0UGF5bWVudCA9IHBheW1lbnRMaW5lc1swXT8ubWF0Y2goLyhcXGR7MSwyfSlcXC9cXGR7MSwyfVxcL1xcZHs0fS8pXG4gICAgICBjb25zdCBzZWNvbmRQYXltZW50ID0gcGF5bWVudExpbmVzWzFdPy5tYXRjaCgvKFxcZHsxLDJ9KVxcL1xcZHsxLDJ9XFwvXFxkezR9LylcblxuICAgICAgaWYgKGZpcnN0UGF5bWVudCAmJiBzZWNvbmRQYXltZW50KSB7XG4gICAgICAgIGNvbnN0IGZpcnN0TW9udGggPSBwYXJzZUludChmaXJzdFBheW1lbnRbMV0pXG4gICAgICAgIGNvbnN0IHNlY29uZE1vbnRoID0gcGFyc2VJbnQoc2Vjb25kUGF5bWVudFsxXSlcblxuICAgICAgICBpZiAoZmlyc3RNb250aCA9PT0gc2Vjb25kTW9udGgpIHtcbiAgICAgICAgICAvLyBTYW1lIG1vbnRoID0gYW5udWFsIHBheW1lbnRzXG4gICAgICAgICAgcmVzdWx0LnBheW1lbnRGcmVxdWVuY3kgPSAnQW5udWFsJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERpZmZlcmVudCBtb250aHMgPSBtb250aGx5IHBheW1lbnRzXG4gICAgICAgICAgcmVzdWx0LnBheW1lbnRGcmVxdWVuY3kgPSAnTW9udGhseSdcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnBheW1lbnRGcmVxdWVuY3kgPSAnTW9udGhseScgLy8gRGVmYXVsdCBmYWxsYmFja1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF5bWVudEZyZXF1ZW5jeSA9ICdNb250aGx5JyAvLyBEZWZhdWx0IGZhbGxiYWNrXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXltZW50RnJlcXVlbmN5ID0gJ01vbnRobHknIC8vIERlZmF1bHQgZmFsbGJhY2tcbiAgfVxuXG4gIC8vIElmIGFubnVhbCBwYXltZW50cyBkZXRlY3RlZCwgY29udmVydCB0byBtb250aGx5IGVxdWl2YWxlbnRcbiAgaWYgKHJlc3VsdC5wYXltZW50RnJlcXVlbmN5ID09PSAnQW5udWFsJyAmJiByZXN1bHQucGF5bWVudEFtb3VudCkge1xuICAgIGNvbnN0IGFubnVhbEFtb3VudCA9IHBhcnNlRmxvYXQocmVzdWx0LnBheW1lbnRBbW91bnQpXG4gICAgY29uc3QgbW9udGhseUFtb3VudCA9IGFubnVhbEFtb3VudCAvIDEyXG4gICAgcmVzdWx0LnBheW1lbnRBbW91bnQgPSBtb250aGx5QW1vdW50LnRvRml4ZWQoMilcbiAgICByZXN1bHQucGF5bWVudEZyZXF1ZW5jeSA9ICdNb250aGx5JyAvLyBDb252ZXJ0IHRvIG1vbnRobHkgZm9yIGNhbGN1bGF0aW9uc1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIEFubnVhbCBJbmNyZWFzZSAlIGZyb20gcGF5bWVudCBjaGFuZ2VzXG4gIC8vIExvZ2ljOiBPbmx5IHVzZSBhdmFpbGFibGUgTENQIHBheW1lbnRzIChTb2xkPSQwLCBMQ1A+JDApXG4gIGlmIChsY3BSb3dzLmxlbmd0aCA+PSAyKSB7XG4gICAgY29uc3QgZmlyc3RBbW91bnQgPSBsY3BSb3dzWzBdLmxjcFxuICAgIGxldCBzZWNvbmRBbW91bnQgPSBmaXJzdEFtb3VudFxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGNwUm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKE1hdGguYWJzKGxjcFJvd3NbaV0ubGNwIC0gZmlyc3RBbW91bnQpID4gMC4wMSkge1xuICAgICAgICBzZWNvbmRBbW91bnQgPSBsY3BSb3dzW2ldLmxjcFxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2Vjb25kQW1vdW50ICE9PSBmaXJzdEFtb3VudCAmJiBmaXJzdEFtb3VudCA+IDApIHtcbiAgICAgIGNvbnN0IHBlcmNlbnRhZ2VJbmNyZWFzZSA9ICgoc2Vjb25kQW1vdW50IC0gZmlyc3RBbW91bnQpIC8gZmlyc3RBbW91bnQpICogMTAwXG4gICAgICByZXN1bHQuYW5udWFsSW5jcmVhc2UgPSBwZXJjZW50YWdlSW5jcmVhc2UudG9GaXhlZCgyKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuIl0sIm5hbWVzIjpbInBhcnNlUGF5bWVudCIsInJhd1RleHQiLCJyZXN1bHQiLCJwYXltZW50Um93UmVnZXgiLCJtYXRjaCIsImxjcFJvd3MiLCJleGVjIiwiZGF0ZVN0ciIsInR5cGUiLCJzb2xkQW1vdW50IiwicGFyc2VGbG9hdCIsInJlcGxhY2UiLCJsY3BBbW91bnQiLCJtIiwiZCIsInkiLCJzcGxpdCIsIm1hcCIsIk51bWJlciIsImRhdGUiLCJEYXRlIiwicHVzaCIsInNvbGQiLCJsY3AiLCJsZW5ndGgiLCJzb3J0IiwiYSIsImIiLCJnZXRUaW1lIiwidG9kYXkiLCJzaXhNb250aHNMYXRlciIsInNldE1vbnRoIiwiZ2V0TW9udGgiLCJmaXJzdExjcERhdGUiLCJzdGFydERhdGUiLCJzdGFydE1vbnRoIiwic3RhcnREYXkiLCJnZXREYXRlIiwic3RhcnRZZWFyIiwiZ2V0RnVsbFllYXIiLCJwYXltZW50U3RhcnREYXRlIiwicGF5bWVudEVuZERhdGUiLCJ0eXBlT2ZQYXltZW50IiwicGF5bWVudEFtb3VudCIsInRvRml4ZWQiLCJmYWxsYmFja01hdGNoIiwiYW1vdW50IiwiYW5udWFsUGF5bWVudFBhdHRlcm4iLCJ0ZXN0IiwicGF5bWVudExpbmVzIiwiZmlyc3RQYXltZW50Iiwic2Vjb25kUGF5bWVudCIsImZpcnN0TW9udGgiLCJwYXJzZUludCIsInNlY29uZE1vbnRoIiwicGF5bWVudEZyZXF1ZW5jeSIsImFubnVhbEFtb3VudCIsIm1vbnRobHlBbW91bnQiLCJmaXJzdEFtb3VudCIsInNlY29uZEFtb3VudCIsImkiLCJNYXRoIiwiYWJzIiwicGVyY2VudGFnZUluY3JlYXNlIiwiYW5udWFsSW5jcmVhc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/parsers/paymentParser.ts\n"));

/***/ })

});