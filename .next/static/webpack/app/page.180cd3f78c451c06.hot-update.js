"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/parsers/paymentParser.ts":
/*!****************************************!*\
  !*** ./utils/parsers/paymentParser.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parsePayment: function() { return /* binding */ parsePayment; }\n/* harmony export */ });\n/**\n * Parser for payment information (LCP amount, frequency, annual increase)\n */ function parsePayment(rawText) {\n    const result = {};\n    // Extract Payment Type and LCP Amount\n    // Logic:\n    // 1. Ignore GP (Guaranteed Payments) - only focus on LCP rows\n    // 2. Use the LCP column value (last column) as the available amount\n    // 3. Find first LCP payment where LCP column > $0 (available payments)\n    // Pattern: Date\\tPayment\\tType\\tSold\\tGuaranteed\\tLCP\n    // Example: 11/1/2025\\t$11,610.60\\tLCP\\t$6,501.94\\t$0.00\\t$5,108.66\n    //          (LCP column = $5,108.66 is the available amount to quote)\n    const paymentRowRegex = /(\\d{1,2}\\/\\d{1,2}\\/\\d{4})\\s+\\$?[\\d,]+\\.?\\d*\\s+(LCP|GP|Guaranteed|COLA)\\s+\\$?([\\d,]+\\.?\\d*)\\s+\\$?([\\d,]+\\.?\\d*)\\s+\\$?([\\d,]+\\.?\\d*)/g;\n    let match;\n    const lcpRows = [];\n    while((match = paymentRowRegex.exec(rawText)) !== null){\n        const dateStr = match[1];\n        const type = match[2];\n        const soldAmount = parseFloat(match[3].replace(/,/g, \"\"));\n        const lcpAmount = parseFloat(match[5].replace(/,/g, \"\"));\n        // Only process LCP type rows\n        if (type !== \"LCP\") continue;\n        // Only include rows where LCP column has available amount > 0\n        if (!(lcpAmount > 0)) continue;\n        const [m, d, y] = dateStr.split(\"/\").map(Number);\n        const date = new Date(y, m - 1, d);\n        lcpRows.push({\n            date,\n            dateStr,\n            sold: soldAmount,\n            lcp: lcpAmount\n        });\n    }\n    if (lcpRows.length > 0) {\n        // Sort by ascending date\n        lcpRows.sort((a, b)=>a.date.getTime() - b.date.getTime());\n        // Start Date Logic: MAX(6 months from today, first available LCP date)\n        const today = new Date();\n        // Calculate 6 months from today properly\n        let sixMonthsLater = new Date(today);\n        sixMonthsLater.setMonth(sixMonthsLater.getMonth() + 6);\n        const firstLcpDate = lcpRows[0].date;\n        // Use whichever is later\n        const startDate = firstLcpDate > sixMonthsLater ? firstLcpDate : sixMonthsLater;\n        // Format date as M/D/YYYY\n        const startMonth = startDate.getMonth() + 1;\n        const startDay = startDate.getDate();\n        const startYear = startDate.getFullYear();\n        result.paymentStartDate = \"\".concat(startMonth, \"/\").concat(startDay, \"/\").concat(startYear);\n        // Note: End date will be calculated in accessDataParser.ts using age rule\n        // (TODAY + MIN(30 years, 75 - age)), not from payment table\n        result.paymentEndDate = lcpRows[lcpRows.length - 1].dateStr;\n        // Payment amount should be the first available LCP amount\n        result.typeOfPayment = \"LCP\";\n        result.paymentAmount = lcpRows[0].lcp.toFixed(2);\n    }\n    // Fallback: If no LCP found with new logic, try old pattern (kept for safety)\n    if (!result.paymentAmount) {\n        const fallbackMatch = rawText.match(/\\d{1,2}\\/\\d{1,2}\\/\\d{4}\\s+\\$?[\\d,]+\\.?\\d*\\s+LCP\\s+\\$?[\\d,]+\\.?\\d*\\s+\\$?[\\d,]+\\.?\\d*\\s+\\$?([\\d,]+\\.?\\d*)/);\n        if (fallbackMatch) {\n            const amount = fallbackMatch[1].replace(/,/g, \"\");\n            if (parseFloat(amount) > 0) {\n                result.paymentAmount = amount;\n                result.typeOfPayment = \"LCP\";\n            }\n        }\n    }\n    // Determine payment frequency based on payment dates\n    const paymentDates = lcpRows.map((row)=>row.dateStr);\n    if (paymentDates.length >= 2) {\n        const firstDate = new Date(paymentDates[0]);\n        const secondDate = new Date(paymentDates[1]);\n        // Calculate months between payments\n        const monthsDiff = (secondDate.getFullYear() - firstDate.getFullYear()) * 12 + (secondDate.getMonth() - firstDate.getMonth());\n        if (monthsDiff === 12) {\n            result.paymentFrequency = \"Annual\";\n        } else if (monthsDiff === 3) {\n            result.paymentFrequency = \"Quarterly\";\n        } else if (monthsDiff === 1) {\n            result.paymentFrequency = \"Monthly\";\n        } else if (monthsDiff === 6) {\n            result.paymentFrequency = \"Semi-Annually\";\n        } else {\n            result.paymentFrequency = \"Monthly\" // Default fallback\n            ;\n        }\n    }\n    // Calculate Annual Increase % from payment changes\n    // Logic: Only use available LCP payments (Sold=$0, LCP>$0)\n    if (lcpRows.length >= 2) {\n        const firstAmount = lcpRows[0].lcp;\n        let secondAmount = firstAmount;\n        for(let i = 1; i < lcpRows.length; i++){\n            if (Math.abs(lcpRows[i].lcp - firstAmount) > 0.01) {\n                secondAmount = lcpRows[i].lcp;\n                break;\n            }\n        }\n        if (secondAmount !== firstAmount && firstAmount > 0) {\n            const percentageIncrease = (secondAmount - firstAmount) / firstAmount * 100;\n            result.annualIncrease = percentageIncrease.toFixed(2);\n        }\n    }\n    return result;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3BhcnNlcnMvcGF5bWVudFBhcnNlci50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0NBRUMsR0FFTSxTQUFTQSxhQUFhQyxPQUFlO0lBUTFDLE1BQU1DLFNBQWMsQ0FBQztJQUVyQixzQ0FBc0M7SUFDdEMsU0FBUztJQUNULDhEQUE4RDtJQUM5RCxvRUFBb0U7SUFDcEUsdUVBQXVFO0lBQ3ZFLHNEQUFzRDtJQUN0RCxtRUFBbUU7SUFDbkUscUVBQXFFO0lBRXJFLE1BQU1DLGtCQUFrQjtJQUV4QixJQUFJQztJQUNKLE1BQU1DLFVBQTZFLEVBQUU7SUFFckYsTUFBTyxDQUFDRCxRQUFRRCxnQkFBZ0JHLElBQUksQ0FBQ0wsUUFBTyxNQUFPLEtBQU07UUFDdkQsTUFBTU0sVUFBVUgsS0FBSyxDQUFDLEVBQUU7UUFDeEIsTUFBTUksT0FBT0osS0FBSyxDQUFDLEVBQUU7UUFDckIsTUFBTUssYUFBYUMsV0FBV04sS0FBSyxDQUFDLEVBQUUsQ0FBQ08sT0FBTyxDQUFDLE1BQU07UUFDckQsTUFBTUMsWUFBWUYsV0FBV04sS0FBSyxDQUFDLEVBQUUsQ0FBQ08sT0FBTyxDQUFDLE1BQU07UUFFcEQsNkJBQTZCO1FBQzdCLElBQUlILFNBQVMsT0FBTztRQUVwQiw4REFBOEQ7UUFDOUQsSUFBSSxDQUFFSSxDQUFBQSxZQUFZLElBQUk7UUFFdEIsTUFBTSxDQUFDQyxHQUFHQyxHQUFHQyxFQUFFLEdBQUdSLFFBQVFTLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUNDO1FBQ3pDLE1BQU1DLE9BQU8sSUFBSUMsS0FBS0wsR0FBR0YsSUFBSSxHQUFHQztRQUNoQ1QsUUFBUWdCLElBQUksQ0FBQztZQUFFRjtZQUFNWjtZQUFTZSxNQUFNYjtZQUFZYyxLQUFLWDtRQUFVO0lBQ2pFO0lBRUEsSUFBSVAsUUFBUW1CLE1BQU0sR0FBRyxHQUFHO1FBQ3RCLHlCQUF5QjtRQUN6Qm5CLFFBQVFvQixJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFB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QUFFLENBQUNoQyxHQUFHO2dCQUM3QjtZQUNGO1FBQ0Y7UUFDQSxJQUFJK0IsaUJBQWlCRCxlQUFlQSxjQUFjLEdBQUc7WUFDbkQsTUFBTUsscUJBQXFCLENBQUVKLGVBQWVELFdBQVUsSUFBS0EsY0FBZTtZQUMxRW5ELE9BQU95RCxjQUFjLEdBQUdELG1CQUFtQmQsT0FBTyxDQUFDO1FBQ3JEO0lBQ0Y7SUFFQSxPQUFPMUM7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9wYXJzZXJzL3BheW1lbnRQYXJzZXIudHM/YWM5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBhcnNlciBmb3IgcGF5bWVudCBpbmZvcm1hdGlvbiAoTENQIGFtb3VudCwgZnJlcXVlbmN5LCBhbm51YWwgaW5jcmVhc2UpXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGF5bWVudChyYXdUZXh0OiBzdHJpbmcpOiB7XG4gIHR5cGVPZlBheW1lbnQ/OiBzdHJpbmdcbiAgcGF5bWVudEFtb3VudD86IHN0cmluZ1xuICBwYXltZW50RnJlcXVlbmN5Pzogc3RyaW5nXG4gIGFubnVhbEluY3JlYXNlPzogc3RyaW5nXG4gIHBheW1lbnRTdGFydERhdGU/OiBzdHJpbmdcbiAgcGF5bWVudEVuZERhdGU/OiBzdHJpbmdcbn0ge1xuICBjb25zdCByZXN1bHQ6IGFueSA9IHt9XG5cbiAgLy8gRXh0cmFjdCBQYXltZW50IFR5cGUgYW5kIExDUCBBbW91bnRcbiAgLy8gTG9naWM6XG4gIC8vIDEuIElnbm9yZSBHUCAoR3VhcmFudGVlZCBQYXltZW50cykgLSBvbmx5IGZvY3VzIG9uIExDUCByb3dzXG4gIC8vIDIuIFVzZSB0aGUgTENQIGNvbHVtbiB2YWx1ZSAobGFzdCBjb2x1bW4pIGFzIHRoZSBhdmFpbGFibGUgYW1vdW50XG4gIC8vIDMuIEZpbmQgZmlyc3QgTENQIHBheW1lbnQgd2hlcmUgTENQIGNvbHVtbiA+ICQwIChhdmFpbGFibGUgcGF5bWVudHMpXG4gIC8vIFBhdHRlcm46IERhdGVcXHRQYXltZW50XFx0VHlwZVxcdFNvbGRcXHRHdWFyYW50ZWVkXFx0TENQXG4gIC8vIEV4YW1wbGU6IDExLzEvMjAyNVxcdCQxMSw2MTAuNjBcXHRMQ1BcXHQkNiw1MDEuOTRcXHQkMC4wMFxcdCQ1LDEwOC42NlxuICAvLyAgICAgICAgICAoTENQIGNvbHVtbiA9ICQ1LDEwOC42NiBpcyB0aGUgYXZhaWxhYmxlIGFtb3VudCB0byBxdW90ZSlcbiAgXG4gIGNvbnN0IHBheW1lbnRSb3dSZWdleCA9IC8oXFxkezEsMn1cXC9cXGR7MSwyfVxcL1xcZHs0fSlcXHMrXFwkP1tcXGQsXStcXC4/XFxkKlxccysoTENQfEdQfEd1YXJhbnRlZWR8Q09MQSlcXHMrXFwkPyhbXFxkLF0rXFwuP1xcZCopXFxzK1xcJD8oW1xcZCxdK1xcLj9cXGQqKVxccytcXCQ/KFtcXGQsXStcXC4/XFxkKikvZ1xuICBcbiAgbGV0IG1hdGNoOiBSZWdFeHBFeGVjQXJyYXkgfCBudWxsXG4gIGNvbnN0IGxjcFJvd3M6IEFycmF5PHsgZGF0ZTogRGF0ZTsgZGF0ZVN0cjogc3RyaW5nOyBzb2xkOiBudW1iZXI7IGxjcDogbnVtYmVyIH0+ID0gW11cblxuICB3aGlsZSAoKG1hdGNoID0gcGF5bWVudFJvd1JlZ2V4LmV4ZWMocmF3VGV4dCkpICE9PSBudWxsKSB7XG4gICAgY29uc3QgZGF0ZVN0ciA9IG1hdGNoWzFdXG4gICAgY29uc3QgdHlwZSA9IG1hdGNoWzJdXG4gICAgY29uc3Qgc29sZEFtb3VudCA9IHBhcnNlRmxvYXQobWF0Y2hbM10ucmVwbGFjZSgvLC9nLCAnJykpXG4gICAgY29uc3QgbGNwQW1vdW50ID0gcGFyc2VGbG9hdChtYXRjaFs1XS5yZXBsYWNlKC8sL2csICcnKSlcblxuICAgIC8vIE9ubHkgcHJvY2VzcyBMQ1AgdHlwZSByb3dzXG4gICAgaWYgKHR5cGUgIT09ICdMQ1AnKSBjb250aW51ZVxuICAgIFxuICAgIC8vIE9ubHkgaW5jbHVkZSByb3dzIHdoZXJlIExDUCBjb2x1bW4gaGFzIGF2YWlsYWJsZSBhbW91bnQgPiAwXG4gICAgaWYgKCEobGNwQW1vdW50ID4gMCkpIGNvbnRpbnVlXG5cbiAgICBjb25zdCBbbSwgZCwgeV0gPSBkYXRlU3RyLnNwbGl0KCcvJykubWFwKE51bWJlcilcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoeSwgbSAtIDEsIGQpXG4gICAgbGNwUm93cy5wdXNoKHsgZGF0ZSwgZGF0ZVN0ciwgc29sZDogc29sZEFtb3VudCwgbGNwOiBsY3BBbW91bnQgfSlcbiAgfVxuXG4gIGlmIChsY3BSb3dzLmxlbmd0aCA+IDApIHtcbiAgICAvLyBTb3J0IGJ5IGFzY2VuZGluZyBkYXRlXG4gICAgbGNwUm93cy5zb3J0KChhLCBiKSA9PiBhLmRhdGUuZ2V0VGltZSgpIC0gYi5kYXRlLmdldFRpbWUoKSlcblxuICAgIC8vIFN0YXJ0IERhdGUgTG9naWM6IE1BWCg2IG1vbnRocyBmcm9tIHRvZGF5LCBmaXJzdCBhdmFpbGFibGUgTENQIGRhdGUpXG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpXG4gICAgLy8gQ2FsY3VsYXRlIDYgbW9udGhzIGZyb20gdG9kYXkgcHJvcGVybHlcbiAgICBsZXQgc2l4TW9udGhzTGF0ZXIgPSBuZXcgRGF0ZSh0b2RheSlcbiAgICBzaXhNb250aHNMYXRlci5zZXRNb250aChzaXhNb250aHNMYXRlci5nZXRNb250aCgpICsgNilcbiAgICBcbiAgICBjb25zdCBmaXJzdExjcERhdGUgPSBsY3BSb3dzWzBdLmRhdGVcbiAgICBcbiAgICAvLyBVc2Ugd2hpY2hldmVyIGlzIGxhdGVyXG4gICAgY29uc3Qgc3RhcnREYXRlID0gZmlyc3RMY3BEYXRlID4gc2l4TW9udGhzTGF0ZXIgPyBmaXJzdExjcERhdGUgOiBzaXhNb250aHNMYXRlclxuICAgIFxuICAgIC8vIEZvcm1hdCBkYXRlIGFzIE0vRC9ZWVlZXG4gICAgY29uc3Qgc3RhcnRNb250aCA9IHN0YXJ0RGF0ZS5nZXRNb250aCgpICsgMVxuICAgIGNvbnN0IHN0YXJ0RGF5ID0gc3RhcnREYXRlLmdldERhdGUoKVxuICAgIGNvbnN0IHN0YXJ0WWVhciA9IHN0YXJ0RGF0ZS5nZXRGdWxsWWVhcigpXG4gICAgcmVzdWx0LnBheW1lbnRTdGFydERhdGUgPSBgJHtzdGFydE1vbnRofS8ke3N0YXJ0RGF5fS8ke3N0YXJ0WWVhcn1gXG5cbiAgICAvLyBOb3RlOiBFbmQgZGF0ZSB3aWxsIGJlIGNhbGN1bGF0ZWQgaW4gYWNjZXNzRGF0YVBhcnNlci50cyB1c2luZyBhZ2UgcnVsZVxuICAgIC8vIChUT0RBWSArIE1JTigzMCB5ZWFycywgNzUgLSBhZ2UpKSwgbm90IGZyb20gcGF5bWVudCB0YWJsZVxuICAgIHJlc3VsdC5wYXltZW50RW5kRGF0ZSA9IGxjcFJvd3NbbGNwUm93cy5sZW5ndGggLSAxXS5kYXRlU3RyXG5cbiAgICAvLyBQYXltZW50IGFtb3VudCBzaG91bGQgYmUgdGhlIGZpcnN0IGF2YWlsYWJsZSBMQ1AgYW1vdW50XG4gICAgcmVzdWx0LnR5cGVPZlBheW1lbnQgPSAnTENQJ1xuICAgIHJlc3VsdC5wYXltZW50QW1vdW50ID0gbGNwUm93c1swXS5sY3AudG9GaXhlZCgyKVxuICB9XG4gIFxuICAvLyBGYWxsYmFjazogSWYgbm8gTENQIGZvdW5kIHdpdGggbmV3IGxvZ2ljLCB0cnkgb2xkIHBhdHRlcm4gKGtlcHQgZm9yIHNhZmV0eSlcbiAgaWYgKCFyZXN1bHQucGF5bWVudEFtb3VudCkge1xuICAgIGNvbnN0IGZhbGxiYWNrTWF0Y2ggPSByYXdUZXh0Lm1hdGNoKC9cXGR7MSwyfVxcL1xcZHsxLDJ9XFwvXFxkezR9XFxzK1xcJD9bXFxkLF0rXFwuP1xcZCpcXHMrTENQXFxzK1xcJD9bXFxkLF0rXFwuP1xcZCpcXHMrXFwkP1tcXGQsXStcXC4/XFxkKlxccytcXCQ/KFtcXGQsXStcXC4/XFxkKikvKVxuICAgIGlmIChmYWxsYmFja01hdGNoKSB7XG4gICAgICBjb25zdCBhbW91bnQgPSBmYWxsYmFja01hdGNoWzFdLnJlcGxhY2UoLywvZywgJycpXG4gICAgICBpZiAocGFyc2VGbG9hdChhbW91bnQpID4gMCkge1xuICAgICAgICByZXN1bHQucGF5bWVudEFtb3VudCA9IGFtb3VudFxuICAgICAgICByZXN1bHQudHlwZU9mUGF5bWVudCA9ICdMQ1AnXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRGV0ZXJtaW5lIHBheW1lbnQgZnJlcXVlbmN5IGJhc2VkIG9uIHBheW1lbnQgZGF0ZXNcbiAgY29uc3QgcGF5bWVudERhdGVzID0gbGNwUm93cy5tYXAocm93ID0+IHJvdy5kYXRlU3RyKVxuICBpZiAocGF5bWVudERhdGVzLmxlbmd0aCA+PSAyKSB7XG4gICAgY29uc3QgZmlyc3REYXRlID0gbmV3IERhdGUocGF5bWVudERhdGVzWzBdKVxuICAgIGNvbnN0IHNlY29uZERhdGUgPSBuZXcgRGF0ZShwYXltZW50RGF0ZXNbMV0pXG5cbiAgICAvLyBDYWxjdWxhdGUgbW9udGhzIGJldHdlZW4gcGF5bWVudHNcbiAgICBjb25zdCBtb250aHNEaWZmID0gKHNlY29uZERhdGUuZ2V0RnVsbFllYXIoKSAtIGZpcnN0RGF0ZS5nZXRGdWxsWWVhcigpKSAqIDEyICtcbiAgICAgICAgICAgICAgICAgICAgICAoc2Vjb25kRGF0ZS5nZXRNb250aCgpIC0gZmlyc3REYXRlLmdldE1vbnRoKCkpXG5cbiAgICBpZiAobW9udGhzRGlmZiA9PT0gMTIpIHtcbiAgICAgIHJlc3VsdC5wYXltZW50RnJlcXVlbmN5ID0gJ0FubnVhbCdcbiAgICB9IGVsc2UgaWYgKG1vbnRoc0RpZmYgPT09IDMpIHtcbiAgICAgIHJlc3VsdC5wYXltZW50RnJlcXVlbmN5ID0gJ1F1YXJ0ZXJseSdcbiAgICB9IGVsc2UgaWYgKG1vbnRoc0RpZmYgPT09IDEpIHtcbiAgICAgIHJlc3VsdC5wYXltZW50RnJlcXVlbmN5ID0gJ01vbnRobHknXG4gICAgfSBlbHNlIGlmIChtb250aHNEaWZmID09PSA2KSB7XG4gICAgICByZXN1bHQucGF5bWVudEZyZXF1ZW5jeSA9ICdTZW1pLUFubnVhbGx5J1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF5bWVudEZyZXF1ZW5jeSA9ICdNb250aGx5JyAvLyBEZWZhdWx0IGZhbGxiYWNrXG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIEFubnVhbCBJbmNyZWFzZSAlIGZyb20gcGF5bWVudCBjaGFuZ2VzXG4gIC8vIExvZ2ljOiBPbmx5IHVzZSBhdmFpbGFibGUgTENQIHBheW1lbnRzIChTb2xkPSQwLCBMQ1A+JDApXG4gIGlmIChsY3BSb3dzLmxlbmd0aCA+PSAyKSB7XG4gICAgY29uc3QgZmlyc3RBbW91bnQgPSBsY3BSb3dzWzBdLmxjcFxuICAgIGxldCBzZWNvbmRBbW91bnQgPSBmaXJzdEFtb3VudFxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGNwUm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKE1hdGguYWJzKGxjcFJvd3NbaV0ubGNwIC0gZmlyc3RBbW91bnQpID4gMC4wMSkge1xuICAgICAgICBzZWNvbmRBbW91bnQgPSBsY3BSb3dzW2ldLmxjcFxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2Vjb25kQW1vdW50ICE9PSBmaXJzdEFtb3VudCAmJiBmaXJzdEFtb3VudCA+IDApIHtcbiAgICAgIGNvbnN0IHBlcmNlbnRhZ2VJbmNyZWFzZSA9ICgoc2Vjb25kQW1vdW50IC0gZmlyc3RBbW91bnQpIC8gZmlyc3RBbW91bnQpICogMTAwXG4gICAgICByZXN1bHQuYW5udWFsSW5jcmVhc2UgPSBwZXJjZW50YWdlSW5jcmVhc2UudG9GaXhlZCgyKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuIl0sIm5hbWVzIjpbInBhcnNlUGF5bWVudCIsInJhd1RleHQiLCJyZXN1bHQiLCJwYXltZW50Um93UmVnZXgiLCJtYXRjaCIsImxjcFJvd3MiLCJleGVjIiwiZGF0ZVN0ciIsInR5cGUiLCJzb2xkQW1vdW50IiwicGFyc2VGbG9hdCIsInJlcGxhY2UiLCJsY3BBbW91bnQiLCJtIiwiZCIsInkiLCJzcGxpdCIsIm1hcCIsIk51bWJlciIsImRhdGUiLCJEYXRlIiwicHVzaCIsInNvbGQiLCJsY3AiLCJsZW5ndGgiLCJzb3J0IiwiYSIsImIiLCJnZXRUaW1lIiwidG9kYXkiLCJzaXhNb250aHNMYXRlciIsInNldE1vbnRoIiwiZ2V0TW9udGgiLCJmaXJzdExjcERhdGUiLCJzdGFydERhdGUiLCJzdGFydE1vbnRoIiwic3RhcnREYXkiLCJnZXREYXRlIiwic3RhcnRZZWFyIiwiZ2V0RnVsbFllYXIiLCJwYXltZW50U3RhcnREYXRlIiwicGF5bWVudEVuZERhdGUiLCJ0eXBlT2ZQYXltZW50IiwicGF5bWVudEFtb3VudCIsInRvRml4ZWQiLCJmYWxsYmFja01hdGNoIiwiYW1vdW50IiwicGF5bWVudERhdGVzIiwicm93IiwiZmlyc3REYXRlIiwic2Vjb25kRGF0ZSIsIm1vbnRoc0RpZmYiLCJwYXltZW50RnJlcXVlbmN5IiwiZmlyc3RBbW91bnQiLCJzZWNvbmRBbW91bnQiLCJpIiwiTWF0aCIsImFicyIsInBlcmNlbnRhZ2VJbmNyZWFzZSIsImFubnVhbEluY3JlYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/parsers/paymentParser.ts\n"));

/***/ })

});