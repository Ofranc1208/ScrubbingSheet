"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/parsers/paymentParser.ts":
/*!****************************************!*\
  !*** ./utils/parsers/paymentParser.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parsePayment: function() { return /* binding */ parsePayment; }\n/* harmony export */ });\n/**\n * Parser for payment information (LCP amount, frequency, annual increase)\n */ function parsePayment(rawText) {\n    const result = {};\n    // Extract Payment Type and LCP Amount\n    // Logic:\n    // 1. Ignore GP (Guaranteed Payments) - only focus on LCP rows\n    // 2. Use the LCP column value (last column) as the available amount\n    // 3. Find first LCP payment where LCP column > $0 (available payments)\n    // Pattern: Date\\tPayment\\tType\\tSold\\tGuaranteed\\tLCP\n    // Example: 11/1/2025\\t$11,610.60\\tLCP\\t$6,501.94\\t$0.00\\t$5,108.66\n    //          (LCP column = $5,108.66 is the available amount to quote)\n    const paymentRowRegex = /(\\d{1,2}\\/\\d{1,2}\\/\\d{4})\\s+\\$?[\\d,]+\\.?\\d*\\s+(LCP|GP|Guaranteed|COLA)\\s+\\$?([\\d,]+\\.?\\d*)\\s+\\$?([\\d,]+\\.?\\d*)\\s+\\$?([\\d,]+\\.?\\d*)/g;\n    let match;\n    const lcpRows = [];\n    while((match = paymentRowRegex.exec(rawText)) !== null){\n        const dateStr = match[1];\n        const type = match[2];\n        const soldAmount = parseFloat(match[3].replace(/,/g, \"\"));\n        const lcpAmount = parseFloat(match[5].replace(/,/g, \"\"));\n        // Only process LCP type rows\n        if (type !== \"LCP\") continue;\n        // Only include rows where LCP column has available amount > 0\n        if (!(lcpAmount > 0)) continue;\n        const [m, d, y] = dateStr.split(\"/\").map(Number);\n        const date = new Date(y, m - 1, d);\n        lcpRows.push({\n            date,\n            dateStr,\n            sold: soldAmount,\n            lcp: lcpAmount\n        });\n    }\n    if (lcpRows.length > 0) {\n        // Sort by ascending date\n        lcpRows.sort((a, b)=>a.date.getTime() - b.date.getTime());\n        // Start Date Logic: MAX(6 months from today, first available LCP date)\n        const today = new Date();\n        // Calculate 6 months from today properly\n        let sixMonthsLater = new Date(today);\n        sixMonthsLater.setMonth(sixMonthsLater.getMonth() + 6);\n        const firstLcpDate = lcpRows[0].date;\n        // Use whichever is later\n        const startDate = firstLcpDate > sixMonthsLater ? firstLcpDate : sixMonthsLater;\n        // Format date as M/D/YYYY\n        const startMonth = startDate.getMonth() + 1;\n        const startDay = startDate.getDate();\n        const startYear = startDate.getFullYear();\n        result.paymentStartDate = \"\".concat(startMonth, \"/\").concat(startDay, \"/\").concat(startYear);\n        // Note: End date will be calculated in accessDataParser.ts using age rule\n        // (TODAY + MIN(30 years, 75 - age)), not from payment table\n        result.paymentEndDate = lcpRows[lcpRows.length - 1].dateStr;\n        // Payment amount should be the first available LCP amount\n        result.typeOfPayment = \"LCP\";\n        result.paymentAmount = lcpRows[0].lcp.toFixed(2);\n    }\n    // Fallback: If no LCP found with new logic, try old pattern (kept for safety)\n    if (!result.paymentAmount) {\n        const fallbackMatch = rawText.match(/\\d{1,2}\\/\\d{1,2}\\/\\d{4}\\s+\\$?[\\d,]+\\.?\\d*\\s+LCP\\s+\\$?[\\d,]+\\.?\\d*\\s+\\$?[\\d,]+\\.?\\d*\\s+\\$?([\\d,]+\\.?\\d*)/);\n        if (fallbackMatch) {\n            const amount = fallbackMatch[1].replace(/,/g, \"\");\n            if (parseFloat(amount) > 0) {\n                result.paymentAmount = amount;\n                result.typeOfPayment = \"LCP\";\n            }\n        }\n    }\n    // Determine payment frequency and handle annual payments\n    // Check for annual payments (same month, different years)\n    const annualPaymentPattern = /\\d{1,2}\\/\\d{1,2}\\/\\d{4}\\s+\\$[\\d,]+\\.?\\d*.*\\n.*\\d{1,2}\\/\\d{1,2}\\/\\d{4}\\s+\\$[\\d,]+\\.?\\d*/;\n    if (annualPaymentPattern.test(rawText)) {\n        // Check if payments are in the same month (annual) or different months (monthly)\n        const paymentLines = rawText.match(/\\d{1,2}\\/\\d{1,2}\\/\\d{4}\\s+\\$[\\d,]+\\.?\\d*/g) || [];\n        if (paymentLines.length >= 2) {\n            const firstPayment = paymentLines[0].match(/(\\d{1,2})\\/\\d{1,2}\\/\\d{4}/);\n            const secondPayment = paymentLines[1].match(/(\\d{1,2})\\/\\d{1,2}\\/\\d{4}/);\n            if (firstPayment && secondPayment) {\n                const firstMonth = parseInt(firstPayment[1]);\n                const secondMonth = parseInt(secondPayment[1]);\n                if (firstMonth === secondMonth) {\n                    // Same month = annual payments\n                    result.paymentFrequency = \"Annual\";\n                } else {\n                    // Different months = monthly payments\n                    result.paymentFrequency = \"Monthly\";\n                }\n            } else {\n                result.paymentFrequency = \"Monthly\" // Default fallback\n                ;\n            }\n        } else {\n            result.paymentFrequency = \"Monthly\" // Default fallback\n            ;\n        }\n    } else {\n        result.paymentFrequency = \"Monthly\" // Default fallback\n        ;\n    }\n    // If annual payments detected, convert to monthly equivalent\n    if (result.paymentFrequency === \"Annual\" && result.paymentAmount) {\n        const annualAmount = parseFloat(result.paymentAmount);\n        const monthlyAmount = annualAmount / 12;\n        result.paymentAmount = monthlyAmount.toFixed(2);\n        result.paymentFrequency = \"Monthly\" // Convert to monthly for calculations\n        ;\n    }\n    // Calculate Annual Increase % from payment changes\n    // Logic: Only use available LCP payments (Sold=$0, LCP>$0)\n    if (lcpRows.length >= 2) {\n        const firstAmount = lcpRows[0].lcp;\n        let secondAmount = firstAmount;\n        for(let i = 1; i < lcpRows.length; i++){\n            if (Math.abs(lcpRows[i].lcp - firstAmount) > 0.01) {\n                secondAmount = lcpRows[i].lcp;\n                break;\n            }\n        }\n        if (secondAmount !== firstAmount && firstAmount > 0) {\n            const percentageIncrease = (secondAmount - firstAmount) / firstAmount * 100;\n            result.annualIncrease = percentageIncrease.toFixed(2);\n        }\n    }\n    return result;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3BhcnNlcnMvcGF5bWVudFBhcnNlci50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0NBRUMsR0FFTSxTQUFTQSxhQUFhQyxPQUFlO0lBUTFDLE1BQU1DLFNBQWMsQ0FBQztJQUVyQixzQ0FBc0M7SUFDdEMsU0FBUztJQUNULDhEQUE4RDtJQUM5RCxvRUFBb0U7SUFDcEUsdUVBQXVFO0lBQ3ZFLHNEQUFzRDtJQUN0RCxtRUFBbUU7SUFDbkUscUVBQXFFO0lBRXJFLE1BQU1DLGtCQUFrQjtJQUV4QixJQUFJQztJQUNKLE1BQU1DLFVBQTZFLEVBQUU7SUFFckYsTUFBTyxDQUFDRCxRQUFRRCxnQkFBZ0JHLElBQUksQ0FBQ0wsUUFBTyxNQUFPLEtBQU07UUFDdkQsTUFBTU0sVUFBVUgsS0FBSyxDQUFDLEVBQUU7UUFDeEIsTUFBTUksT0FBT0osS0FBSyxDQUFDLEVBQUU7UUFDckIsTUFBTUssYUFBYUMsV0FBV04sS0FBSyxDQUFDLEVBQUUsQ0FBQ08sT0FBTyxDQUFDLE1BQU07UUFDckQsTUFBTUMsWUFBWUYsV0FBV04sS0FBSyxDQUFDLEVBQUUsQ0FBQ08sT0FBTyxDQUFDLE1BQU07UUFFcEQsNkJBQTZCO1FBQzdCLElBQUlILFNBQVMsT0FBTztRQUVwQiw4REFBOEQ7UUFDOUQsSUFBSSxDQUFFSSxDQUFBQSxZQUFZLElBQUk7UUFFdEIsTUFBTSxDQUFDQyxHQUFHQyxHQUFHQyxFQUFFLEdBQUdSLFFBQVFTLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUNDO1FBQ3pDLE1BQU1DLE9BQU8sSUFBSUMsS0FBS0wsR0FBR0YsSUFBSSxHQUFHQztRQUNoQ1QsUUFBUWdCLElBQUksQ0FBQztZQUFFRjtZQUFNWjtZQUFTZSxNQUFNYjtZQUFZYyxLQUFLWDtRQUFVO0lBQ2pFO0lBRUEsSUFBSVAsUUFBUW1CLE1BQU0sR0FBRyxHQUFHO1FBQ3RCLHlCQUF5QjtRQUN6Qm5CLFFBQVFvQixJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFB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QXNDOztJQUM1RTtJQUVBLG1EQUFtRDtJQUNuRCwyREFBMkQ7SUFDM0QsSUFBSWxELFFBQVFtQixNQUFNLElBQUksR0FBRztRQUN2QixNQUFNa0MsY0FBY3JELE9BQU8sQ0FBQyxFQUFFLENBQUNrQixHQUFHO1FBQ2xDLElBQUlvQyxlQUFlRDtRQUNuQixJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSXZELFFBQVFtQixNQUFNLEVBQUVvQyxJQUFLO1lBQ3ZDLElBQUlDLEtBQUtDLEdBQUcsQ0FBQ3pELE9BQU8sQ0FBQ3VELEVBQUUsQ0FBQ3JDLEdBQUcsR0FBR21DLGVBQWUsTUFBTTtnQkFDakRDLGVBQWV0RCxPQUFPLENBQUN1RCxFQUFFLENBQUNyQyxHQUFHO2dCQUM3QjtZQUNGO1FBQ0Y7UUFDQSxJQUFJb0MsaUJBQWlCRCxlQUFlQSxjQUFjLEdBQUc7WUFDbkQsTUFBTUsscUJBQXFCLENBQUVKLGVBQWVELFdBQVUsSUFBS0EsY0FBZTtZQUMxRXhELE9BQU84RCxjQUFjLEdBQUdELG1CQUFtQm5CLE9BQU8sQ0FBQztRQUNyRDtJQUNGO0lBRUEsT0FBTzFDO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvcGFyc2Vycy9wYXltZW50UGFyc2VyLnRzP2FjOWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQYXJzZXIgZm9yIHBheW1lbnQgaW5mb3JtYXRpb24gKExDUCBhbW91bnQsIGZyZXF1ZW5jeSwgYW5udWFsIGluY3JlYXNlKVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVBheW1lbnQocmF3VGV4dDogc3RyaW5nKToge1xuICB0eXBlT2ZQYXltZW50Pzogc3RyaW5nXG4gIHBheW1lbnRBbW91bnQ/OiBzdHJpbmdcbiAgcGF5bWVudEZyZXF1ZW5jeT86IHN0cmluZ1xuICBhbm51YWxJbmNyZWFzZT86IHN0cmluZ1xuICBwYXltZW50U3RhcnREYXRlPzogc3RyaW5nXG4gIHBheW1lbnRFbmREYXRlPzogc3RyaW5nXG59IHtcbiAgY29uc3QgcmVzdWx0OiBhbnkgPSB7fVxuXG4gIC8vIEV4dHJhY3QgUGF5bWVudCBUeXBlIGFuZCBMQ1AgQW1vdW50XG4gIC8vIExvZ2ljOlxuICAvLyAxLiBJZ25vcmUgR1AgKEd1YXJhbnRlZWQgUGF5bWVudHMpIC0gb25seSBmb2N1cyBvbiBMQ1Agcm93c1xuICAvLyAyLiBVc2UgdGhlIExDUCBjb2x1bW4gdmFsdWUgKGxhc3QgY29sdW1uKSBhcyB0aGUgYXZhaWxhYmxlIGFtb3VudFxuICAvLyAzLiBGaW5kIGZpcnN0IExDUCBwYXltZW50IHdoZXJlIExDUCBjb2x1bW4gPiAkMCAoYXZhaWxhYmxlIHBheW1lbnRzKVxuICAvLyBQYXR0ZXJuOiBEYXRlXFx0UGF5bWVudFxcdFR5cGVcXHRTb2xkXFx0R3VhcmFudGVlZFxcdExDUFxuICAvLyBFeGFtcGxlOiAxMS8xLzIwMjVcXHQkMTEsNjEwLjYwXFx0TENQXFx0JDYsNTAxLjk0XFx0JDAuMDBcXHQkNSwxMDguNjZcbiAgLy8gICAgICAgICAgKExDUCBjb2x1bW4gPSAkNSwxMDguNjYgaXMgdGhlIGF2YWlsYWJsZSBhbW91bnQgdG8gcXVvdGUpXG4gIFxuICBjb25zdCBwYXltZW50Um93UmVnZXggPSAvKFxcZHsxLDJ9XFwvXFxkezEsMn1cXC9cXGR7NH0pXFxzK1xcJD9bXFxkLF0rXFwuP1xcZCpcXHMrKExDUHxHUHxHdWFyYW50ZWVkfENPTEEpXFxzK1xcJD8oW1xcZCxdK1xcLj9cXGQqKVxccytcXCQ/KFtcXGQsXStcXC4/XFxkKilcXHMrXFwkPyhbXFxkLF0rXFwuP1xcZCopL2dcbiAgXG4gIGxldCBtYXRjaDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbFxuICBjb25zdCBsY3BSb3dzOiBBcnJheTx7IGRhdGU6IERhdGU7IGRhdGVTdHI6IHN0cmluZzsgc29sZDogbnVtYmVyOyBsY3A6IG51bWJlciB9PiA9IFtdXG5cbiAgd2hpbGUgKChtYXRjaCA9IHBheW1lbnRSb3dSZWdleC5leGVjKHJhd1RleHQpKSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGRhdGVTdHIgPSBtYXRjaFsxXVxuICAgIGNvbnN0IHR5cGUgPSBtYXRjaFsyXVxuICAgIGNvbnN0IHNvbGRBbW91bnQgPSBwYXJzZUZsb2F0KG1hdGNoWzNdLnJlcGxhY2UoLywvZywgJycpKVxuICAgIGNvbnN0IGxjcEFtb3VudCA9IHBhcnNlRmxvYXQobWF0Y2hbNV0ucmVwbGFjZSgvLC9nLCAnJykpXG5cbiAgICAvLyBPbmx5IHByb2Nlc3MgTENQIHR5cGUgcm93c1xuICAgIGlmICh0eXBlICE9PSAnTENQJykgY29udGludWVcbiAgICBcbiAgICAvLyBPbmx5IGluY2x1ZGUgcm93cyB3aGVyZSBMQ1AgY29sdW1uIGhhcyBhdmFpbGFibGUgYW1vdW50ID4gMFxuICAgIGlmICghKGxjcEFtb3VudCA+IDApKSBjb250aW51ZVxuXG4gICAgY29uc3QgW20sIGQsIHldID0gZGF0ZVN0ci5zcGxpdCgnLycpLm1hcChOdW1iZXIpXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHksIG0gLSAxLCBkKVxuICAgIGxjcFJvd3MucHVzaCh7IGRhdGUsIGRhdGVTdHIsIHNvbGQ6IHNvbGRBbW91bnQsIGxjcDogbGNwQW1vdW50IH0pXG4gIH1cblxuICBpZiAobGNwUm93cy5sZW5ndGggPiAwKSB7XG4gICAgLy8gU29ydCBieSBhc2NlbmRpbmcgZGF0ZVxuICAgIGxjcFJvd3Muc29ydCgoYSwgYikgPT4gYS5kYXRlLmdldFRpbWUoKSAtIGIuZGF0ZS5nZXRUaW1lKCkpXG5cbiAgICAvLyBTdGFydCBEYXRlIExvZ2ljOiBNQVgoNiBtb250aHMgZnJvbSB0b2RheSwgZmlyc3QgYXZhaWxhYmxlIExDUCBkYXRlKVxuICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKVxuICAgIC8vIENhbGN1bGF0ZSA2IG1vbnRocyBmcm9tIHRvZGF5IHByb3Blcmx5XG4gICAgbGV0IHNpeE1vbnRoc0xhdGVyID0gbmV3IERhdGUodG9kYXkpXG4gICAgc2l4TW9udGhzTGF0ZXIuc2V0TW9udGgoc2l4TW9udGhzTGF0ZXIuZ2V0TW9udGgoKSArIDYpXG4gICAgXG4gICAgY29uc3QgZmlyc3RMY3BEYXRlID0gbGNwUm93c1swXS5kYXRlXG4gICAgXG4gICAgLy8gVXNlIHdoaWNoZXZlciBpcyBsYXRlclxuICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IGZpcnN0TGNwRGF0ZSA+IHNpeE1vbnRoc0xhdGVyID8gZmlyc3RMY3BEYXRlIDogc2l4TW9udGhzTGF0ZXJcbiAgICBcbiAgICAvLyBGb3JtYXQgZGF0ZSBhcyBNL0QvWVlZWVxuICAgIGNvbnN0IHN0YXJ0TW9udGggPSBzdGFydERhdGUuZ2V0TW9udGgoKSArIDFcbiAgICBjb25zdCBzdGFydERheSA9IHN0YXJ0RGF0ZS5nZXREYXRlKClcbiAgICBjb25zdCBzdGFydFllYXIgPSBzdGFydERhdGUuZ2V0RnVsbFllYXIoKVxuICAgIHJlc3VsdC5wYXltZW50U3RhcnREYXRlID0gYCR7c3RhcnRNb250aH0vJHtzdGFydERheX0vJHtzdGFydFllYXJ9YFxuXG4gICAgLy8gTm90ZTogRW5kIGRhdGUgd2lsbCBiZSBjYWxjdWxhdGVkIGluIGFjY2Vzc0RhdGFQYXJzZXIudHMgdXNpbmcgYWdlIHJ1bGVcbiAgICAvLyAoVE9EQVkgKyBNSU4oMzAgeWVhcnMsIDc1IC0gYWdlKSksIG5vdCBmcm9tIHBheW1lbnQgdGFibGVcbiAgICByZXN1bHQucGF5bWVudEVuZERhdGUgPSBsY3BSb3dzW2xjcFJvd3MubGVuZ3RoIC0gMV0uZGF0ZVN0clxuXG4gICAgLy8gUGF5bWVudCBhbW91bnQgc2hvdWxkIGJlIHRoZSBmaXJzdCBhdmFpbGFibGUgTENQIGFtb3VudFxuICAgIHJlc3VsdC50eXBlT2ZQYXltZW50ID0gJ0xDUCdcbiAgICByZXN1bHQucGF5bWVudEFtb3VudCA9IGxjcFJvd3NbMF0ubGNwLnRvRml4ZWQoMilcbiAgfVxuICBcbiAgLy8gRmFsbGJhY2s6IElmIG5vIExDUCBmb3VuZCB3aXRoIG5ldyBsb2dpYywgdHJ5IG9sZCBwYXR0ZXJuIChrZXB0IGZvciBzYWZldHkpXG4gIGlmICghcmVzdWx0LnBheW1lbnRBbW91bnQpIHtcbiAgICBjb25zdCBmYWxsYmFja01hdGNoID0gcmF3VGV4dC5tYXRjaCgvXFxkezEsMn1cXC9cXGR7MSwyfVxcL1xcZHs0fVxccytcXCQ/W1xcZCxdK1xcLj9cXGQqXFxzK0xDUFxccytcXCQ/W1xcZCxdK1xcLj9cXGQqXFxzK1xcJD9bXFxkLF0rXFwuP1xcZCpcXHMrXFwkPyhbXFxkLF0rXFwuP1xcZCopLylcbiAgICBpZiAoZmFsbGJhY2tNYXRjaCkge1xuICAgICAgY29uc3QgYW1vdW50ID0gZmFsbGJhY2tNYXRjaFsxXS5yZXBsYWNlKC8sL2csICcnKVxuICAgICAgaWYgKHBhcnNlRmxvYXQoYW1vdW50KSA+IDApIHtcbiAgICAgICAgcmVzdWx0LnBheW1lbnRBbW91bnQgPSBhbW91bnRcbiAgICAgICAgcmVzdWx0LnR5cGVPZlBheW1lbnQgPSAnTENQJ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIERldGVybWluZSBwYXltZW50IGZyZXF1ZW5jeSBhbmQgaGFuZGxlIGFubnVhbCBwYXltZW50c1xuICAvLyBDaGVjayBmb3IgYW5udWFsIHBheW1lbnRzIChzYW1lIG1vbnRoLCBkaWZmZXJlbnQgeWVhcnMpXG4gIGNvbnN0IGFubnVhbFBheW1lbnRQYXR0ZXJuID0gL1xcZHsxLDJ9XFwvXFxkezEsMn1cXC9cXGR7NH1cXHMrXFwkW1xcZCxdK1xcLj9cXGQqLipcXG4uKlxcZHsxLDJ9XFwvXFxkezEsMn1cXC9cXGR7NH1cXHMrXFwkW1xcZCxdK1xcLj9cXGQqL1xuICBpZiAoYW5udWFsUGF5bWVudFBhdHRlcm4udGVzdChyYXdUZXh0KSkge1xuICAgIC8vIENoZWNrIGlmIHBheW1lbnRzIGFyZSBpbiB0aGUgc2FtZSBtb250aCAoYW5udWFsKSBvciBkaWZmZXJlbnQgbW9udGhzIChtb250aGx5KVxuICAgIGNvbnN0IHBheW1lbnRMaW5lcyA9IHJhd1RleHQubWF0Y2goL1xcZHsxLDJ9XFwvXFxkezEsMn1cXC9cXGR7NH1cXHMrXFwkW1xcZCxdK1xcLj9cXGQqL2cpIHx8IFtdXG4gICAgaWYgKHBheW1lbnRMaW5lcy5sZW5ndGggPj0gMikge1xuICAgICAgY29uc3QgZmlyc3RQYXltZW50ID0gcGF5bWVudExpbmVzWzBdLm1hdGNoKC8oXFxkezEsMn0pXFwvXFxkezEsMn1cXC9cXGR7NH0vKVxuICAgICAgY29uc3Qgc2Vjb25kUGF5bWVudCA9IHBheW1lbnRMaW5lc1sxXS5tYXRjaCgvKFxcZHsxLDJ9KVxcL1xcZHsxLDJ9XFwvXFxkezR9LylcblxuICAgICAgaWYgKGZpcnN0UGF5bWVudCAmJiBzZWNvbmRQYXltZW50KSB7XG4gICAgICAgIGNvbnN0IGZpcnN0TW9udGggPSBwYXJzZUludChmaXJzdFBheW1lbnRbMV0pXG4gICAgICAgIGNvbnN0IHNlY29uZE1vbnRoID0gcGFyc2VJbnQoc2Vjb25kUGF5bWVudFsxXSlcblxuICAgICAgICBpZiAoZmlyc3RNb250aCA9PT0gc2Vjb25kTW9udGgpIHtcbiAgICAgICAgICAvLyBTYW1lIG1vbnRoID0gYW5udWFsIHBheW1lbnRzXG4gICAgICAgICAgcmVzdWx0LnBheW1lbnRGcmVxdWVuY3kgPSAnQW5udWFsJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERpZmZlcmVudCBtb250aHMgPSBtb250aGx5IHBheW1lbnRzXG4gICAgICAgICAgcmVzdWx0LnBheW1lbnRGcmVxdWVuY3kgPSAnTW9udGhseSdcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnBheW1lbnRGcmVxdWVuY3kgPSAnTW9udGhseScgLy8gRGVmYXVsdCBmYWxsYmFja1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF5bWVudEZyZXF1ZW5jeSA9ICdNb250aGx5JyAvLyBEZWZhdWx0IGZhbGxiYWNrXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXltZW50RnJlcXVlbmN5ID0gJ01vbnRobHknIC8vIERlZmF1bHQgZmFsbGJhY2tcbiAgfVxuXG4gIC8vIElmIGFubnVhbCBwYXltZW50cyBkZXRlY3RlZCwgY29udmVydCB0byBtb250aGx5IGVxdWl2YWxlbnRcbiAgaWYgKHJlc3VsdC5wYXltZW50RnJlcXVlbmN5ID09PSAnQW5udWFsJyAmJiByZXN1bHQucGF5bWVudEFtb3VudCkge1xuICAgIGNvbnN0IGFubnVhbEFtb3VudCA9IHBhcnNlRmxvYXQocmVzdWx0LnBheW1lbnRBbW91bnQpXG4gICAgY29uc3QgbW9udGhseUFtb3VudCA9IGFubnVhbEFtb3VudCAvIDEyXG4gICAgcmVzdWx0LnBheW1lbnRBbW91bnQgPSBtb250aGx5QW1vdW50LnRvRml4ZWQoMilcbiAgICByZXN1bHQucGF5bWVudEZyZXF1ZW5jeSA9ICdNb250aGx5JyAvLyBDb252ZXJ0IHRvIG1vbnRobHkgZm9yIGNhbGN1bGF0aW9uc1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIEFubnVhbCBJbmNyZWFzZSAlIGZyb20gcGF5bWVudCBjaGFuZ2VzXG4gIC8vIExvZ2ljOiBPbmx5IHVzZSBhdmFpbGFibGUgTENQIHBheW1lbnRzIChTb2xkPSQwLCBMQ1A+JDApXG4gIGlmIChsY3BSb3dzLmxlbmd0aCA+PSAyKSB7XG4gICAgY29uc3QgZmlyc3RBbW91bnQgPSBsY3BSb3dzWzBdLmxjcFxuICAgIGxldCBzZWNvbmRBbW91bnQgPSBmaXJzdEFtb3VudFxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGNwUm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKE1hdGguYWJzKGxjcFJvd3NbaV0ubGNwIC0gZmlyc3RBbW91bnQpID4gMC4wMSkge1xuICAgICAgICBzZWNvbmRBbW91bnQgPSBsY3BSb3dzW2ldLmxjcFxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2Vjb25kQW1vdW50ICE9PSBmaXJzdEFtb3VudCAmJiBmaXJzdEFtb3VudCA+IDApIHtcbiAgICAgIGNvbnN0IHBlcmNlbnRhZ2VJbmNyZWFzZSA9ICgoc2Vjb25kQW1vdW50IC0gZmlyc3RBbW91bnQpIC8gZmlyc3RBbW91bnQpICogMTAwXG4gICAgICByZXN1bHQuYW5udWFsSW5jcmVhc2UgPSBwZXJjZW50YWdlSW5jcmVhc2UudG9GaXhlZCgyKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuIl0sIm5hbWVzIjpbInBhcnNlUGF5bWVudCIsInJhd1RleHQiLCJyZXN1bHQiLCJwYXltZW50Um93UmVnZXgiLCJtYXRjaCIsImxjcFJvd3MiLCJleGVjIiwiZGF0ZVN0ciIsInR5cGUiLCJzb2xkQW1vdW50IiwicGFyc2VGbG9hdCIsInJlcGxhY2UiLCJsY3BBbW91bnQiLCJtIiwiZCIsInkiLCJzcGxpdCIsIm1hcCIsIk51bWJlciIsImRhdGUiLCJEYXRlIiwicHVzaCIsInNvbGQiLCJsY3AiLCJsZW5ndGgiLCJzb3J0IiwiYSIsImIiLCJnZXRUaW1lIiwidG9kYXkiLCJzaXhNb250aHNMYXRlciIsInNldE1vbnRoIiwiZ2V0TW9udGgiLCJmaXJzdExjcERhdGUiLCJzdGFydERhdGUiLCJzdGFydE1vbnRoIiwic3RhcnREYXkiLCJnZXREYXRlIiwic3RhcnRZZWFyIiwiZ2V0RnVsbFllYXIiLCJwYXltZW50U3RhcnREYXRlIiwicGF5bWVudEVuZERhdGUiLCJ0eXBlT2ZQYXltZW50IiwicGF5bWVudEFtb3VudCIsInRvRml4ZWQiLCJmYWxsYmFja01hdGNoIiwiYW1vdW50IiwiYW5udWFsUGF5bWVudFBhdHRlcm4iLCJ0ZXN0IiwicGF5bWVudExpbmVzIiwiZmlyc3RQYXltZW50Iiwic2Vjb25kUGF5bWVudCIsImZpcnN0TW9udGgiLCJwYXJzZUludCIsInNlY29uZE1vbnRoIiwicGF5bWVudEZyZXF1ZW5jeSIsImFubnVhbEFtb3VudCIsIm1vbnRobHlBbW91bnQiLCJmaXJzdEFtb3VudCIsInNlY29uZEFtb3VudCIsImkiLCJNYXRoIiwiYWJzIiwicGVyY2VudGFnZUluY3JlYXNlIiwiYW5udWFsSW5jcmVhc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/parsers/paymentParser.ts\n"));

/***/ })

});